
/* eslint-disable */
/*
 * This file is the generated parser to convert grammar to Abstract Syntax Tree (AST)
 *
 * DO NOT EDIT THIS FILE. As all changes will be lost.
 * To edit the grammar, edit parse.txt and regenerate this file with generate_parser.py
 */
import { Token, TokenStream } from "./tokenize";
import { ParseFunction, ParseResultEpsilon, ParseResultFail } from "./types";

/*import-validation-exempt*/import { parseInteger, ASTInteger, parseIdentifier, ASTIdentifier } from "./ast.basis";


export type ASTEpsilon = null;
export const isEpsilon = <T>(node: T | ASTEpsilon): node is ASTEpsilon => node === null;
const parseEpsilon = (_: TokenStream) => ParseResultEpsilon;

// (derivation union) Target => Command | SuperCommand
const parseTarget: ParseFunction<ASTTarget> = (tokens) => {
	let result: ASTTarget | undefined;
	result = parseCommand(tokens);
	if(result !== ParseResultFail) return result;
	result = parseSuperCommand(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTTarget = ASTCommand | ASTSuperCommand;
// (derivation) SuperCommandForCommand => <!> Command
export const isSuperCommandForCommand = <T extends {type: string}>(node: T | ASTSuperCommandForCommand | null): node is ASTSuperCommandForCommand => Boolean(node && node.type === "ASTSuperCommandForCommand");
export type ASTSuperCommandForCommand = {
	readonly type: "ASTSuperCommandForCommand",
	readonly literal0: readonly [number, number],
	readonly mCommand1: ASTCommand,
};
const parseSuperCommandForCommand: ParseFunction<ASTSuperCommandForCommand> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "!") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mCommand1 = parseCommand(tokens);
	if(mCommand1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTSuperCommandForCommand",
		literal0,
		mCommand1,
	};
};
// (derivation union) Command => CommandInitGameData | CommandInitialize | CommandCook | CommandCookCrit | CommandAdd | CommandPickUp | CommandRemoveAll | CommandRemove | CommandDrop | CommandEat | CommandDnp | CommandEquip | CommandUnequipAll | CommandUnequip | CommandShoot | CommandEnterTrial | CommandExitTrial | CommandWriteMetadata | CommandSave | CommandReload | CommandBreakSlots | CommandCloseGame | CommandSyncGameData
const parseCommand: ParseFunction<ASTCommand> = (tokens) => {
	let result: ASTCommand | undefined;
	result = parseCommandInitGameData(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandInitialize(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandCook(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandCookCrit(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandAdd(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandPickUp(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandRemoveAll(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandRemove(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandDrop(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandEat(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandDnp(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandEquip(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandUnequipAll(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandUnequip(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandShoot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandEnterTrial(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandExitTrial(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandWriteMetadata(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandSave(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandReload(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandBreakSlots(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandCloseGame(tokens);
	if(result !== ParseResultFail) return result;
	result = parseCommandSyncGameData(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTCommand = ASTCommandInitGameData | ASTCommandInitialize | ASTCommandCook | ASTCommandCookCrit | ASTCommandAdd | ASTCommandPickUp | ASTCommandRemoveAll | ASTCommandRemove | ASTCommandDrop | ASTCommandEat | ASTCommandDnp | ASTCommandEquip | ASTCommandUnequipAll | ASTCommandUnequip | ASTCommandShoot | ASTCommandEnterTrial | ASTCommandExitTrial | ASTCommandWriteMetadata | ASTCommandSave | ASTCommandReload | ASTCommandBreakSlots | ASTCommandCloseGame | ASTCommandSyncGameData;
// (derivation union) SuperCommand => SuperCommandAddSlot | SuperCommandRemoveSlot | SuperCommandForCommand
const parseSuperCommand: ParseFunction<ASTSuperCommand> = (tokens) => {
	let result: ASTSuperCommand | undefined;
	result = parseSuperCommandAddSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseSuperCommandRemoveSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseSuperCommandForCommand(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTSuperCommand = ASTSuperCommandAddSlot | ASTSuperCommandRemoveSlot | ASTSuperCommandForCommand;
// (derivation) CommandInitGameData => LiteralInitialize <gamedata> ZeroOrMoreItems
export const isCommandInitGameData = <T extends {type: string}>(node: T | ASTCommandInitGameData | null): node is ASTCommandInitGameData => Boolean(node && node.type === "ASTCommandInitGameData");
export type ASTCommandInitGameData = {
	readonly type: "ASTCommandInitGameData",
	readonly mLiteralInitialize0: ASTLiteralInitialize,
	readonly literal1: readonly [number, number],
	readonly mZeroOrMoreItems2: ASTZeroOrMoreItems,
};
const parseCommandInitGameData: ParseFunction<ASTCommandInitGameData> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mLiteralInitialize0 = parseLiteralInitialize(tokens);
	if(mLiteralInitialize0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "gamedata") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal1 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mZeroOrMoreItems2 = parseZeroOrMoreItems(tokens);
	if(mZeroOrMoreItems2 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandInitGameData",
		mLiteralInitialize0,
		literal1,
		mZeroOrMoreItems2,
	};
};
// (derivation) CommandInitialize => LiteralInitialize ZeroOrMoreItems
export const isCommandInitialize = <T extends {type: string}>(node: T | ASTCommandInitialize | null): node is ASTCommandInitialize => Boolean(node && node.type === "ASTCommandInitialize");
export type ASTCommandInitialize = {
	readonly type: "ASTCommandInitialize",
	readonly mLiteralInitialize0: ASTLiteralInitialize,
	readonly mZeroOrMoreItems1: ASTZeroOrMoreItems,
};
const parseCommandInitialize: ParseFunction<ASTCommandInitialize> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mLiteralInitialize0 = parseLiteralInitialize(tokens);
	if(mLiteralInitialize0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mZeroOrMoreItems1 = parseZeroOrMoreItems(tokens);
	if(mZeroOrMoreItems1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandInitialize",
		mLiteralInitialize0,
		mZeroOrMoreItems1,
	};
};
// (derivation) CommandCook => <cook> <with> ArgumentOneOrMoreItemsAllowAllMaybeFromSlot
export const isCommandCook = <T extends {type: string}>(node: T | ASTCommandCook | null): node is ASTCommandCook => Boolean(node && node.type === "ASTCommandCook");
export type ASTCommandCook = {
	readonly type: "ASTCommandCook",
	readonly literal0: readonly [number, number],
	readonly literal1: readonly [number, number],
	readonly mArgumentOneOrMoreItemsAllowAllMaybeFromSlot2: ASTArgumentOneOrMoreItemsAllowAllMaybeFromSlot,
};
const parseCommandCook: ParseFunction<ASTCommandCook> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "cook") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "with") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal1 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mArgumentOneOrMoreItemsAllowAllMaybeFromSlot2 = parseArgumentOneOrMoreItemsAllowAllMaybeFromSlot(tokens);
	if(mArgumentOneOrMoreItemsAllowAllMaybeFromSlot2 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandCook",
		literal0,
		literal1,
		mArgumentOneOrMoreItemsAllowAllMaybeFromSlot2,
	};
};
// (derivation) CommandCookCrit => <cook> <heart> <crit> <with> ArgumentOneOrMoreItemsAllowAllMaybeFromSlot
export const isCommandCookCrit = <T extends {type: string}>(node: T | ASTCommandCookCrit | null): node is ASTCommandCookCrit => Boolean(node && node.type === "ASTCommandCookCrit");
export type ASTCommandCookCrit = {
	readonly type: "ASTCommandCookCrit",
	readonly literal0: readonly [number, number],
	readonly literal1: readonly [number, number],
	readonly literal2: readonly [number, number],
	readonly literal3: readonly [number, number],
	readonly mArgumentOneOrMoreItemsAllowAllMaybeFromSlot4: ASTArgumentOneOrMoreItemsAllowAllMaybeFromSlot,
};
const parseCommandCookCrit: ParseFunction<ASTCommandCookCrit> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "cook") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "heart") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal1 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "crit") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal2 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "with") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal3 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mArgumentOneOrMoreItemsAllowAllMaybeFromSlot4 = parseArgumentOneOrMoreItemsAllowAllMaybeFromSlot(tokens);
	if(mArgumentOneOrMoreItemsAllowAllMaybeFromSlot4 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandCookCrit",
		literal0,
		literal1,
		literal2,
		literal3,
		mArgumentOneOrMoreItemsAllowAllMaybeFromSlot4,
	};
};
// (derivation) CommandAdd => LiteralAdd OneOrMoreItems
export const isCommandAdd = <T extends {type: string}>(node: T | ASTCommandAdd | null): node is ASTCommandAdd => Boolean(node && node.type === "ASTCommandAdd");
export type ASTCommandAdd = {
	readonly type: "ASTCommandAdd",
	readonly mLiteralAdd0: ASTLiteralAdd,
	readonly mOneOrMoreItems1: ASTOneOrMoreItems,
};
const parseCommandAdd: ParseFunction<ASTCommandAdd> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mLiteralAdd0 = parseLiteralAdd(tokens);
	if(mLiteralAdd0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mOneOrMoreItems1 = parseOneOrMoreItems(tokens);
	if(mOneOrMoreItems1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandAdd",
		mLiteralAdd0,
		mOneOrMoreItems1,
	};
};
// (derivation) CommandPickUp => LiteralPickUp OneOrMoreItems
export const isCommandPickUp = <T extends {type: string}>(node: T | ASTCommandPickUp | null): node is ASTCommandPickUp => Boolean(node && node.type === "ASTCommandPickUp");
export type ASTCommandPickUp = {
	readonly type: "ASTCommandPickUp",
	readonly mLiteralPickUp0: ASTLiteralPickUp,
	readonly mOneOrMoreItems1: ASTOneOrMoreItems,
};
const parseCommandPickUp: ParseFunction<ASTCommandPickUp> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mLiteralPickUp0 = parseLiteralPickUp(tokens);
	if(mLiteralPickUp0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mOneOrMoreItems1 = parseOneOrMoreItems(tokens);
	if(mOneOrMoreItems1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandPickUp",
		mLiteralPickUp0,
		mOneOrMoreItems1,
	};
};
// (derivation) CommandRemoveAll => <remove> <all> LiteralItemType
export const isCommandRemoveAll = <T extends {type: string}>(node: T | ASTCommandRemoveAll | null): node is ASTCommandRemoveAll => Boolean(node && node.type === "ASTCommandRemoveAll");
export type ASTCommandRemoveAll = {
	readonly type: "ASTCommandRemoveAll",
	readonly literal0: readonly [number, number],
	readonly literal1: readonly [number, number],
	readonly mLiteralItemType2: ASTLiteralItemType,
};
const parseCommandRemoveAll: ParseFunction<ASTCommandRemoveAll> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "remove") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "all") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal1 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mLiteralItemType2 = parseLiteralItemType(tokens);
	if(mLiteralItemType2 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandRemoveAll",
		literal0,
		literal1,
		mLiteralItemType2,
	};
};
// (derivation) CommandRemove => LiteralRemove ArgumentOneOrMoreItemsAllowAllMaybeFromSlot
export const isCommandRemove = <T extends {type: string}>(node: T | ASTCommandRemove | null): node is ASTCommandRemove => Boolean(node && node.type === "ASTCommandRemove");
export type ASTCommandRemove = {
	readonly type: "ASTCommandRemove",
	readonly mLiteralRemove0: ASTLiteralRemove,
	readonly mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1: ASTArgumentOneOrMoreItemsAllowAllMaybeFromSlot,
};
const parseCommandRemove: ParseFunction<ASTCommandRemove> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mLiteralRemove0 = parseLiteralRemove(tokens);
	if(mLiteralRemove0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1 = parseArgumentOneOrMoreItemsAllowAllMaybeFromSlot(tokens);
	if(mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandRemove",
		mLiteralRemove0,
		mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1,
	};
};
// (derivation) CommandDrop => <drop> ArgumentOneOrMoreItemsAllowAllMaybeFromSlot
export const isCommandDrop = <T extends {type: string}>(node: T | ASTCommandDrop | null): node is ASTCommandDrop => Boolean(node && node.type === "ASTCommandDrop");
export type ASTCommandDrop = {
	readonly type: "ASTCommandDrop",
	readonly literal0: readonly [number, number],
	readonly mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1: ASTArgumentOneOrMoreItemsAllowAllMaybeFromSlot,
};
const parseCommandDrop: ParseFunction<ASTCommandDrop> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "drop") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1 = parseArgumentOneOrMoreItemsAllowAllMaybeFromSlot(tokens);
	if(mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandDrop",
		literal0,
		mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1,
	};
};
// (derivation) CommandEat => <eat> ArgumentOneOrMoreItemsAllowAllMaybeFromSlot
export const isCommandEat = <T extends {type: string}>(node: T | ASTCommandEat | null): node is ASTCommandEat => Boolean(node && node.type === "ASTCommandEat");
export type ASTCommandEat = {
	readonly type: "ASTCommandEat",
	readonly literal0: readonly [number, number],
	readonly mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1: ASTArgumentOneOrMoreItemsAllowAllMaybeFromSlot,
};
const parseCommandEat: ParseFunction<ASTCommandEat> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "eat") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1 = parseArgumentOneOrMoreItemsAllowAllMaybeFromSlot(tokens);
	if(mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandEat",
		literal0,
		mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1,
	};
};
// (derivation) CommandDnp => LiteralDnp ArgumentOneOrMoreItemsAllowAllMaybeFromSlot
export const isCommandDnp = <T extends {type: string}>(node: T | ASTCommandDnp | null): node is ASTCommandDnp => Boolean(node && node.type === "ASTCommandDnp");
export type ASTCommandDnp = {
	readonly type: "ASTCommandDnp",
	readonly mLiteralDnp0: ASTLiteralDnp,
	readonly mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1: ASTArgumentOneOrMoreItemsAllowAllMaybeFromSlot,
};
const parseCommandDnp: ParseFunction<ASTCommandDnp> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mLiteralDnp0 = parseLiteralDnp(tokens);
	if(mLiteralDnp0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1 = parseArgumentOneOrMoreItemsAllowAllMaybeFromSlot(tokens);
	if(mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandDnp",
		mLiteralDnp0,
		mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1,
	};
};
// (derivation) CommandEquip => <equip> ArgumentSingleItemMaybeInSlot
export const isCommandEquip = <T extends {type: string}>(node: T | ASTCommandEquip | null): node is ASTCommandEquip => Boolean(node && node.type === "ASTCommandEquip");
export type ASTCommandEquip = {
	readonly type: "ASTCommandEquip",
	readonly literal0: readonly [number, number],
	readonly mArgumentSingleItemMaybeInSlot1: ASTArgumentSingleItemMaybeInSlot,
};
const parseCommandEquip: ParseFunction<ASTCommandEquip> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "equip") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mArgumentSingleItemMaybeInSlot1 = parseArgumentSingleItemMaybeInSlot(tokens);
	if(mArgumentSingleItemMaybeInSlot1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandEquip",
		literal0,
		mArgumentSingleItemMaybeInSlot1,
	};
};
// (derivation) CommandUnequipAll => <unequip> LiteralMaybeAllItemType
export const isCommandUnequipAll = <T extends {type: string}>(node: T | ASTCommandUnequipAll | null): node is ASTCommandUnequipAll => Boolean(node && node.type === "ASTCommandUnequipAll");
export type ASTCommandUnequipAll = {
	readonly type: "ASTCommandUnequipAll",
	readonly literal0: readonly [number, number],
	readonly mLiteralMaybeAllItemType1: ASTLiteralMaybeAllItemType,
};
const parseCommandUnequipAll: ParseFunction<ASTCommandUnequipAll> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "unequip") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mLiteralMaybeAllItemType1 = parseLiteralMaybeAllItemType(tokens);
	if(mLiteralMaybeAllItemType1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandUnequipAll",
		literal0,
		mLiteralMaybeAllItemType1,
	};
};
// (derivation) CommandUnequip => <unequip> ArgumentSingleItemMaybeInSlot
export const isCommandUnequip = <T extends {type: string}>(node: T | ASTCommandUnequip | null): node is ASTCommandUnequip => Boolean(node && node.type === "ASTCommandUnequip");
export type ASTCommandUnequip = {
	readonly type: "ASTCommandUnequip",
	readonly literal0: readonly [number, number],
	readonly mArgumentSingleItemMaybeInSlot1: ASTArgumentSingleItemMaybeInSlot,
};
const parseCommandUnequip: ParseFunction<ASTCommandUnequip> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "unequip") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mArgumentSingleItemMaybeInSlot1 = parseArgumentSingleItemMaybeInSlot(tokens);
	if(mArgumentSingleItemMaybeInSlot1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandUnequip",
		literal0,
		mArgumentSingleItemMaybeInSlot1,
	};
};
// (derivation) CommandShoot => <shoot> AmountOrAll LiteralArrow
export const isCommandShoot = <T extends {type: string}>(node: T | ASTCommandShoot | null): node is ASTCommandShoot => Boolean(node && node.type === "ASTCommandShoot");
export type ASTCommandShoot = {
	readonly type: "ASTCommandShoot",
	readonly literal0: readonly [number, number],
	readonly mAmountOrAll1: ASTAmountOrAll,
	readonly mLiteralArrow2: ASTLiteralArrow,
};
const parseCommandShoot: ParseFunction<ASTCommandShoot> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "shoot") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mAmountOrAll1 = parseAmountOrAll(tokens);
	if(mAmountOrAll1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mLiteralArrow2 = parseLiteralArrow(tokens);
	if(mLiteralArrow2 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandShoot",
		literal0,
		mAmountOrAll1,
		mLiteralArrow2,
	};
};
// (derivation) CommandEnterTrial => <enter> LiteralTrial
export const isCommandEnterTrial = <T extends {type: string}>(node: T | ASTCommandEnterTrial | null): node is ASTCommandEnterTrial => Boolean(node && node.type === "ASTCommandEnterTrial");
export type ASTCommandEnterTrial = {
	readonly type: "ASTCommandEnterTrial",
	readonly literal0: readonly [number, number],
	readonly mLiteralTrial1: ASTLiteralTrial,
};
const parseCommandEnterTrial: ParseFunction<ASTCommandEnterTrial> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "enter") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mLiteralTrial1 = parseLiteralTrial(tokens);
	if(mLiteralTrial1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandEnterTrial",
		literal0,
		mLiteralTrial1,
	};
};
// (derivation) CommandExitTrial => LiteralLeave LiteralTrial
export const isCommandExitTrial = <T extends {type: string}>(node: T | ASTCommandExitTrial | null): node is ASTCommandExitTrial => Boolean(node && node.type === "ASTCommandExitTrial");
export type ASTCommandExitTrial = {
	readonly type: "ASTCommandExitTrial",
	readonly mLiteralLeave0: ASTLiteralLeave,
	readonly mLiteralTrial1: ASTLiteralTrial,
};
const parseCommandExitTrial: ParseFunction<ASTCommandExitTrial> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mLiteralLeave0 = parseLiteralLeave(tokens);
	if(mLiteralLeave0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mLiteralTrial1 = parseLiteralTrial(tokens);
	if(mLiteralTrial1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandExitTrial",
		mLiteralLeave0,
		mLiteralTrial1,
	};
};
// (derivation) CommandWriteMetadata => <write> Metadata <to> ArgumentSingleItemMaybeInSlot
export const isCommandWriteMetadata = <T extends {type: string}>(node: T | ASTCommandWriteMetadata | null): node is ASTCommandWriteMetadata => Boolean(node && node.type === "ASTCommandWriteMetadata");
export type ASTCommandWriteMetadata = {
	readonly type: "ASTCommandWriteMetadata",
	readonly literal0: readonly [number, number],
	readonly mMetadata1: ASTMetadata,
	readonly literal2: readonly [number, number],
	readonly mArgumentSingleItemMaybeInSlot3: ASTArgumentSingleItemMaybeInSlot,
};
const parseCommandWriteMetadata: ParseFunction<ASTCommandWriteMetadata> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "write") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mMetadata1 = parseMetadata(tokens);
	if(mMetadata1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "to") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal2 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mArgumentSingleItemMaybeInSlot3 = parseArgumentSingleItemMaybeInSlot(tokens);
	if(mArgumentSingleItemMaybeInSlot3 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandWriteMetadata",
		literal0,
		mMetadata1,
		literal2,
		mArgumentSingleItemMaybeInSlot3,
	};
};
// (derivation) CommandSave => <save> MaybeClauseSaveTarget
export const isCommandSave = <T extends {type: string}>(node: T | ASTCommandSave | null): node is ASTCommandSave => Boolean(node && node.type === "ASTCommandSave");
export type ASTCommandSave = {
	readonly type: "ASTCommandSave",
	readonly literal0: readonly [number, number],
	readonly mMaybeClauseSaveTarget1: ASTMaybeClauseSaveTarget,
};
const parseCommandSave: ParseFunction<ASTCommandSave> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "save") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mMaybeClauseSaveTarget1 = parseMaybeClauseSaveTarget(tokens);
	if(mMaybeClauseSaveTarget1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandSave",
		literal0,
		mMaybeClauseSaveTarget1,
	};
};
// (derivation) CommandReload => <reload> IdentifierPrime
export const isCommandReload = <T extends {type: string}>(node: T | ASTCommandReload | null): node is ASTCommandReload => Boolean(node && node.type === "ASTCommandReload");
export type ASTCommandReload = {
	readonly type: "ASTCommandReload",
	readonly literal0: readonly [number, number],
	readonly mIdentifierPrime1: ASTIdentifierPrime,
};
const parseCommandReload: ParseFunction<ASTCommandReload> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "reload") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mIdentifierPrime1 = parseIdentifierPrime(tokens);
	if(mIdentifierPrime1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandReload",
		literal0,
		mIdentifierPrime1,
	};
};
// (derivation) CommandBreakSlots => <break> Integer LiteralSlot MaybeArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot
export const isCommandBreakSlots = <T extends {type: string}>(node: T | ASTCommandBreakSlots | null): node is ASTCommandBreakSlots => Boolean(node && node.type === "ASTCommandBreakSlots");
export type ASTCommandBreakSlots = {
	readonly type: "ASTCommandBreakSlots",
	readonly literal0: readonly [number, number],
	readonly mInteger1: ASTInteger,
	readonly mLiteralSlot2: ASTLiteralSlot,
	readonly mMaybeArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot3: ASTMaybeArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot,
};
const parseCommandBreakSlots: ParseFunction<ASTCommandBreakSlots> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "break") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mInteger1 = parseInteger(tokens);
	if(mInteger1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mLiteralSlot2 = parseLiteralSlot(tokens);
	if(mLiteralSlot2 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mMaybeArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot3 = parseMaybeArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot(tokens);
	if(mMaybeArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot3 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTCommandBreakSlots",
		literal0,
		mInteger1,
		mLiteralSlot2,
		mMaybeArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot3,
	};
};
// (derivation) CommandCloseGame => LiteralClose <game>
export const isCommandCloseGame = <T extends {type: string}>(node: T | ASTCommandCloseGame | null): node is ASTCommandCloseGame => Boolean(node && node.type === "ASTCommandCloseGame");
export type ASTCommandCloseGame = {
	readonly type: "ASTCommandCloseGame",
	readonly mLiteralClose0: ASTLiteralClose,
	readonly literal1: readonly [number, number],
};
const parseCommandCloseGame: ParseFunction<ASTCommandCloseGame> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mLiteralClose0 = parseLiteralClose(tokens);
	if(mLiteralClose0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "game") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal1 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	tokens.pop();
	return {
		type: "ASTCommandCloseGame",
		mLiteralClose0,
		literal1,
	};
};
// (derivation) CommandSyncGameData => <sync> <gamedata>
export const isCommandSyncGameData = <T extends {type: string}>(node: T | ASTCommandSyncGameData | null): node is ASTCommandSyncGameData => Boolean(node && node.type === "ASTCommandSyncGameData");
export type ASTCommandSyncGameData = {
	readonly type: "ASTCommandSyncGameData",
	readonly literal0: readonly [number, number],
	readonly literal1: readonly [number, number],
};
const parseCommandSyncGameData: ParseFunction<ASTCommandSyncGameData> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "sync") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "gamedata") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal1 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	tokens.pop();
	return {
		type: "ASTCommandSyncGameData",
		literal0,
		literal1,
	};
};
// (derivation) SuperCommandAddSlot => <!> <add> LiteralSlot ArgumentOneOrMoreItemsMaybeFromSlot
export const isSuperCommandAddSlot = <T extends {type: string}>(node: T | ASTSuperCommandAddSlot | null): node is ASTSuperCommandAddSlot => Boolean(node && node.type === "ASTSuperCommandAddSlot");
export type ASTSuperCommandAddSlot = {
	readonly type: "ASTSuperCommandAddSlot",
	readonly literal0: readonly [number, number],
	readonly literal1: readonly [number, number],
	readonly mLiteralSlot2: ASTLiteralSlot,
	readonly mArgumentOneOrMoreItemsMaybeFromSlot3: ASTArgumentOneOrMoreItemsMaybeFromSlot,
};
const parseSuperCommandAddSlot: ParseFunction<ASTSuperCommandAddSlot> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "!") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "add") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal1 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mLiteralSlot2 = parseLiteralSlot(tokens);
	if(mLiteralSlot2 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mArgumentOneOrMoreItemsMaybeFromSlot3 = parseArgumentOneOrMoreItemsMaybeFromSlot(tokens);
	if(mArgumentOneOrMoreItemsMaybeFromSlot3 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTSuperCommandAddSlot",
		literal0,
		literal1,
		mLiteralSlot2,
		mArgumentOneOrMoreItemsMaybeFromSlot3,
	};
};
// (derivation) SuperCommandRemoveSlot => <!> <remove> LiteralSlot Integer
export const isSuperCommandRemoveSlot = <T extends {type: string}>(node: T | ASTSuperCommandRemoveSlot | null): node is ASTSuperCommandRemoveSlot => Boolean(node && node.type === "ASTSuperCommandRemoveSlot");
export type ASTSuperCommandRemoveSlot = {
	readonly type: "ASTSuperCommandRemoveSlot",
	readonly literal0: readonly [number, number],
	readonly literal1: readonly [number, number],
	readonly mLiteralSlot2: ASTLiteralSlot,
	readonly mInteger3: ASTInteger,
};
const parseSuperCommandRemoveSlot: ParseFunction<ASTSuperCommandRemoveSlot> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "!") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "remove") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal1 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mLiteralSlot2 = parseLiteralSlot(tokens);
	if(mLiteralSlot2 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mInteger3 = parseInteger(tokens);
	if(mInteger3 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTSuperCommandRemoveSlot",
		literal0,
		literal1,
		mLiteralSlot2,
		mInteger3,
	};
};
// (literal union) LiteralInitialize => <initialize> | <init>
export const isLiteralInitialize = <T extends {type: string}>(node: T | ASTLiteralInitialize | null): node is ASTLiteralInitialize => Boolean(node && node.type === "ASTLiteralInitialize");
export type ASTLiteralInitialize = {
	type: "ASTLiteralInitialize";
	range: [number, number];
};
const parseLiteralInitialize: ParseFunction<ASTLiteralInitialize> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "initialize"){
		tokens.pop();
		return {
			type: "ASTLiteralInitialize",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "init"){
		tokens.pop();
		return {
			type: "ASTLiteralInitialize",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralAdd => <get> | <add> | <buy> | <cook>
export const isLiteralAdd = <T extends {type: string}>(node: T | ASTLiteralAdd | null): node is ASTLiteralAdd => Boolean(node && node.type === "ASTLiteralAdd");
export type ASTLiteralAdd = {
	type: "ASTLiteralAdd";
	range: [number, number];
};
const parseLiteralAdd: ParseFunction<ASTLiteralAdd> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "get"){
		tokens.pop();
		return {
			type: "ASTLiteralAdd",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "add"){
		tokens.pop();
		return {
			type: "ASTLiteralAdd",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "buy"){
		tokens.pop();
		return {
			type: "ASTLiteralAdd",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "cook"){
		tokens.pop();
		return {
			type: "ASTLiteralAdd",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralPickUp => <pickup> | <pick> <up>
export const isLiteralPickUp = <T extends {type: string}>(node: T | ASTLiteralPickUp | null): node is ASTLiteralPickUp => Boolean(node && node.type === "ASTLiteralPickUp");
export type ASTLiteralPickUp = {
	type: "ASTLiteralPickUp";
	range: [number, number];
};
const parseLiteralPickUp: ParseFunction<ASTLiteralPickUp> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "pickup"){
		tokens.pop();
		return {
			type: "ASTLiteralPickUp",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "pick" && tokens.consume(rangeTokens) === "up"){
		tokens.pop();
		return {
			type: "ASTLiteralPickUp",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralRemove => <with> | <remove> | <sell>
export const isLiteralRemove = <T extends {type: string}>(node: T | ASTLiteralRemove | null): node is ASTLiteralRemove => Boolean(node && node.type === "ASTLiteralRemove");
export type ASTLiteralRemove = {
	type: "ASTLiteralRemove";
	range: [number, number];
};
const parseLiteralRemove: ParseFunction<ASTLiteralRemove> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "with"){
		tokens.pop();
		return {
			type: "ASTLiteralRemove",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "remove"){
		tokens.pop();
		return {
			type: "ASTLiteralRemove",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "sell"){
		tokens.pop();
		return {
			type: "ASTLiteralRemove",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralDnp => <d&p> | <dnp> | <dap>
export const isLiteralDnp = <T extends {type: string}>(node: T | ASTLiteralDnp | null): node is ASTLiteralDnp => Boolean(node && node.type === "ASTLiteralDnp");
export type ASTLiteralDnp = {
	type: "ASTLiteralDnp";
	range: [number, number];
};
const parseLiteralDnp: ParseFunction<ASTLiteralDnp> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "d&p"){
		tokens.pop();
		return {
			type: "ASTLiteralDnp",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "dnp"){
		tokens.pop();
		return {
			type: "ASTLiteralDnp",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "dap"){
		tokens.pop();
		return {
			type: "ASTLiteralDnp",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralLeave => <exit> | <leave>
export const isLiteralLeave = <T extends {type: string}>(node: T | ASTLiteralLeave | null): node is ASTLiteralLeave => Boolean(node && node.type === "ASTLiteralLeave");
export type ASTLiteralLeave = {
	type: "ASTLiteralLeave";
	range: [number, number];
};
const parseLiteralLeave: ParseFunction<ASTLiteralLeave> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "exit"){
		tokens.pop();
		return {
			type: "ASTLiteralLeave",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "leave"){
		tokens.pop();
		return {
			type: "ASTLiteralLeave",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralClose => <exit> | <close>
export const isLiteralClose = <T extends {type: string}>(node: T | ASTLiteralClose | null): node is ASTLiteralClose => Boolean(node && node.type === "ASTLiteralClose");
export type ASTLiteralClose = {
	type: "ASTLiteralClose";
	range: [number, number];
};
const parseLiteralClose: ParseFunction<ASTLiteralClose> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "exit"){
		tokens.pop();
		return {
			type: "ASTLiteralClose",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "close"){
		tokens.pop();
		return {
			type: "ASTLiteralClose",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralTrial => <eventide> | <tots>
export const isLiteralTrial = <T extends {type: string}>(node: T | ASTLiteralTrial | null): node is ASTLiteralTrial => Boolean(node && node.type === "ASTLiteralTrial");
export type ASTLiteralTrial = {
	type: "ASTLiteralTrial";
	range: [number, number];
};
const parseLiteralTrial: ParseFunction<ASTLiteralTrial> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "eventide"){
		tokens.pop();
		return {
			type: "ASTLiteralTrial",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "tots"){
		tokens.pop();
		return {
			type: "ASTLiteralTrial",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (derivation) LiteralMaybeAllItemType => LiteralMaybeAll LiteralItemType
export const isLiteralMaybeAllItemType = <T extends {type: string}>(node: T | ASTLiteralMaybeAllItemType | null): node is ASTLiteralMaybeAllItemType => Boolean(node && node.type === "ASTLiteralMaybeAllItemType");
export type ASTLiteralMaybeAllItemType = {
	readonly type: "ASTLiteralMaybeAllItemType",
	readonly mLiteralMaybeAll0: ASTLiteralMaybeAll,
	readonly mLiteralItemType1: ASTLiteralItemType,
};
const parseLiteralMaybeAllItemType: ParseFunction<ASTLiteralMaybeAllItemType> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mLiteralMaybeAll0 = parseLiteralMaybeAll(tokens);
	if(mLiteralMaybeAll0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mLiteralItemType1 = parseLiteralItemType(tokens);
	if(mLiteralItemType1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTLiteralMaybeAllItemType",
		mLiteralMaybeAll0,
		mLiteralItemType1,
	};
};
// (derivation union) LiteralItemType => LiteralWeapon | LiteralBow | LiteralArrow | LiteralShield | LiteralArmor | LiteralMaterial | LiteralFood | LiteralKeyItem
const parseLiteralItemType: ParseFunction<ASTLiteralItemType> = (tokens) => {
	let result: ASTLiteralItemType | undefined;
	result = parseLiteralWeapon(tokens);
	if(result !== ParseResultFail) return result;
	result = parseLiteralBow(tokens);
	if(result !== ParseResultFail) return result;
	result = parseLiteralArrow(tokens);
	if(result !== ParseResultFail) return result;
	result = parseLiteralShield(tokens);
	if(result !== ParseResultFail) return result;
	result = parseLiteralArmor(tokens);
	if(result !== ParseResultFail) return result;
	result = parseLiteralMaterial(tokens);
	if(result !== ParseResultFail) return result;
	result = parseLiteralFood(tokens);
	if(result !== ParseResultFail) return result;
	result = parseLiteralKeyItem(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTLiteralItemType = ASTLiteralWeapon | ASTLiteralBow | ASTLiteralArrow | ASTLiteralShield | ASTLiteralArmor | ASTLiteralMaterial | ASTLiteralFood | ASTLiteralKeyItem;
// (literal union) LiteralWeapon => <weapon> | <weapons>
export const isLiteralWeapon = <T extends {type: string}>(node: T | ASTLiteralWeapon | null): node is ASTLiteralWeapon => Boolean(node && node.type === "ASTLiteralWeapon");
export type ASTLiteralWeapon = {
	type: "ASTLiteralWeapon";
	range: [number, number];
};
const parseLiteralWeapon: ParseFunction<ASTLiteralWeapon> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "weapon"){
		tokens.pop();
		return {
			type: "ASTLiteralWeapon",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "weapons"){
		tokens.pop();
		return {
			type: "ASTLiteralWeapon",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralBow => <bow> | <bows>
export const isLiteralBow = <T extends {type: string}>(node: T | ASTLiteralBow | null): node is ASTLiteralBow => Boolean(node && node.type === "ASTLiteralBow");
export type ASTLiteralBow = {
	type: "ASTLiteralBow";
	range: [number, number];
};
const parseLiteralBow: ParseFunction<ASTLiteralBow> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "bow"){
		tokens.pop();
		return {
			type: "ASTLiteralBow",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "bows"){
		tokens.pop();
		return {
			type: "ASTLiteralBow",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralArrow => <arrow> | <arrows>
export const isLiteralArrow = <T extends {type: string}>(node: T | ASTLiteralArrow | null): node is ASTLiteralArrow => Boolean(node && node.type === "ASTLiteralArrow");
export type ASTLiteralArrow = {
	type: "ASTLiteralArrow";
	range: [number, number];
};
const parseLiteralArrow: ParseFunction<ASTLiteralArrow> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "arrow"){
		tokens.pop();
		return {
			type: "ASTLiteralArrow",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "arrows"){
		tokens.pop();
		return {
			type: "ASTLiteralArrow",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralShield => <shield> | <shields>
export const isLiteralShield = <T extends {type: string}>(node: T | ASTLiteralShield | null): node is ASTLiteralShield => Boolean(node && node.type === "ASTLiteralShield");
export type ASTLiteralShield = {
	type: "ASTLiteralShield";
	range: [number, number];
};
const parseLiteralShield: ParseFunction<ASTLiteralShield> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "shield"){
		tokens.pop();
		return {
			type: "ASTLiteralShield",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "shields"){
		tokens.pop();
		return {
			type: "ASTLiteralShield",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralArmor => <armor> | <armors>
export const isLiteralArmor = <T extends {type: string}>(node: T | ASTLiteralArmor | null): node is ASTLiteralArmor => Boolean(node && node.type === "ASTLiteralArmor");
export type ASTLiteralArmor = {
	type: "ASTLiteralArmor";
	range: [number, number];
};
const parseLiteralArmor: ParseFunction<ASTLiteralArmor> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "armor"){
		tokens.pop();
		return {
			type: "ASTLiteralArmor",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "armors"){
		tokens.pop();
		return {
			type: "ASTLiteralArmor",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralMaterial => <material> | <materials>
export const isLiteralMaterial = <T extends {type: string}>(node: T | ASTLiteralMaterial | null): node is ASTLiteralMaterial => Boolean(node && node.type === "ASTLiteralMaterial");
export type ASTLiteralMaterial = {
	type: "ASTLiteralMaterial";
	range: [number, number];
};
const parseLiteralMaterial: ParseFunction<ASTLiteralMaterial> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "material"){
		tokens.pop();
		return {
			type: "ASTLiteralMaterial",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "materials"){
		tokens.pop();
		return {
			type: "ASTLiteralMaterial",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralFood => <food> | <foods>
export const isLiteralFood = <T extends {type: string}>(node: T | ASTLiteralFood | null): node is ASTLiteralFood => Boolean(node && node.type === "ASTLiteralFood");
export type ASTLiteralFood = {
	type: "ASTLiteralFood";
	range: [number, number];
};
const parseLiteralFood: ParseFunction<ASTLiteralFood> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "food"){
		tokens.pop();
		return {
			type: "ASTLiteralFood",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "foods"){
		tokens.pop();
		return {
			type: "ASTLiteralFood",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (derivation) LiteralKeyItem => <key> LiteralItem
export const isLiteralKeyItem = <T extends {type: string}>(node: T | ASTLiteralKeyItem | null): node is ASTLiteralKeyItem => Boolean(node && node.type === "ASTLiteralKeyItem");
export type ASTLiteralKeyItem = {
	readonly type: "ASTLiteralKeyItem",
	readonly literal0: readonly [number, number],
	readonly mLiteralItem1: ASTLiteralItem,
};
const parseLiteralKeyItem: ParseFunction<ASTLiteralKeyItem> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "key") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mLiteralItem1 = parseLiteralItem(tokens);
	if(mLiteralItem1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTLiteralKeyItem",
		literal0,
		mLiteralItem1,
	};
};
// (literal union) LiteralItem => <item> | <items>
export const isLiteralItem = <T extends {type: string}>(node: T | ASTLiteralItem | null): node is ASTLiteralItem => Boolean(node && node.type === "ASTLiteralItem");
export type ASTLiteralItem = {
	type: "ASTLiteralItem";
	range: [number, number];
};
const parseLiteralItem: ParseFunction<ASTLiteralItem> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "item"){
		tokens.pop();
		return {
			type: "ASTLiteralItem",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "items"){
		tokens.pop();
		return {
			type: "ASTLiteralItem",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (literal union) LiteralSlot => <slot> | <slots>
export const isLiteralSlot = <T extends {type: string}>(node: T | ASTLiteralSlot | null): node is ASTLiteralSlot => Boolean(node && node.type === "ASTLiteralSlot");
export type ASTLiteralSlot = {
	type: "ASTLiteralSlot";
	range: [number, number];
};
const parseLiteralSlot: ParseFunction<ASTLiteralSlot> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "slot"){
		tokens.pop();
		return {
			type: "ASTLiteralSlot",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "slots"){
		tokens.pop();
		return {
			type: "ASTLiteralSlot",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (derivation union) LiteralMaybeAll => LiteralAll | Epsilon
const parseLiteralMaybeAll: ParseFunction<ASTLiteralMaybeAll> = (tokens) => {
	let result: ASTLiteralMaybeAll | undefined;
	result = parseLiteralAll(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTLiteralMaybeAll = ASTLiteralAll | ASTEpsilon;
// (derivation) LiteralAll => <all>
export const isLiteralAll = <T extends {type: string}>(node: T | ASTLiteralAll | null): node is ASTLiteralAll => Boolean(node && node.type === "ASTLiteralAll");
export type ASTLiteralAll = {
	readonly type: "ASTLiteralAll",
	readonly literal0: readonly [number, number],
};
const parseLiteralAll: ParseFunction<ASTLiteralAll> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "all") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	tokens.pop();
	return {
		type: "ASTLiteralAll",
		literal0,
	};
};
// (derivation union) MaybeArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot => ArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot | Epsilon
const parseMaybeArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot: ParseFunction<ASTMaybeArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot> = (tokens) => {
	let result: ASTMaybeArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot | undefined;
	result = parseArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTMaybeArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot = ASTArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot | ASTEpsilon;
// (derivation) ArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot => <with> ArgumentOneOrMoreItemsAllowAllMaybeFromSlot
export const isArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot = <T extends {type: string}>(node: T | ASTArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot | null): node is ASTArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot => Boolean(node && node.type === "ASTArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot");
export type ASTArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot = {
	readonly type: "ASTArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot",
	readonly literal0: readonly [number, number],
	readonly mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1: ASTArgumentOneOrMoreItemsAllowAllMaybeFromSlot,
};
const parseArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot: ParseFunction<ASTArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "with") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1 = parseArgumentOneOrMoreItemsAllowAllMaybeFromSlot(tokens);
	if(mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTArgumentWithOneOrMoreItemsAllowAllMaybeFromSlot",
		literal0,
		mArgumentOneOrMoreItemsAllowAllMaybeFromSlot1,
	};
};
// (derivation) ArgumentSingleItemMaybeInSlot => Identifier ArgumentSingleItemMaybeInSlotAIdentifier
export const isArgumentSingleItemMaybeInSlot = <T extends {type: string}>(node: T | ASTArgumentSingleItemMaybeInSlot | null): node is ASTArgumentSingleItemMaybeInSlot => Boolean(node && node.type === "ASTArgumentSingleItemMaybeInSlot");
export type ASTArgumentSingleItemMaybeInSlot = {
	readonly type: "ASTArgumentSingleItemMaybeInSlot",
	readonly mIdentifier0: ASTIdentifier,
	readonly mArgumentSingleItemMaybeInSlotAIdentifier1: ASTArgumentSingleItemMaybeInSlotAIdentifier,
};
const parseArgumentSingleItemMaybeInSlot: ParseFunction<ASTArgumentSingleItemMaybeInSlot> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mIdentifier0 = parseIdentifier(tokens);
	if(mIdentifier0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mArgumentSingleItemMaybeInSlotAIdentifier1 = parseArgumentSingleItemMaybeInSlotAIdentifier(tokens);
	if(mArgumentSingleItemMaybeInSlotAIdentifier1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTArgumentSingleItemMaybeInSlot",
		mIdentifier0,
		mArgumentSingleItemMaybeInSlotAIdentifier1,
	};
};
// (derivation union) ArgumentSingleItemMaybeInSlotAIdentifier => ClauseInSlot | ArgumentSingleItemMaybeInSlotAIdentifierC2 | Epsilon
const parseArgumentSingleItemMaybeInSlotAIdentifier: ParseFunction<ASTArgumentSingleItemMaybeInSlotAIdentifier> = (tokens) => {
	let result: ASTArgumentSingleItemMaybeInSlotAIdentifier | undefined;
	result = parseClauseInSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentSingleItemMaybeInSlotAIdentifierC2(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTArgumentSingleItemMaybeInSlotAIdentifier = ASTClauseInSlot | ASTArgumentSingleItemMaybeInSlotAIdentifierC2 | ASTEpsilon;
// (derivation) ArgumentSingleItemMaybeInSlotAIdentifierC2 => Identifier ArgumentSingleItemMaybeInSlotAIdentifier
export const isArgumentSingleItemMaybeInSlotAIdentifierC2 = <T extends {type: string}>(node: T | ASTArgumentSingleItemMaybeInSlotAIdentifierC2 | null): node is ASTArgumentSingleItemMaybeInSlotAIdentifierC2 => Boolean(node && node.type === "ASTArgumentSingleItemMaybeInSlotAIdentifierC2");
export type ASTArgumentSingleItemMaybeInSlotAIdentifierC2 = {
	readonly type: "ASTArgumentSingleItemMaybeInSlotAIdentifierC2",
	readonly mIdentifier0: ASTIdentifier,
	readonly mArgumentSingleItemMaybeInSlotAIdentifier1: ASTArgumentSingleItemMaybeInSlotAIdentifier,
};
const parseArgumentSingleItemMaybeInSlotAIdentifierC2: ParseFunction<ASTArgumentSingleItemMaybeInSlotAIdentifierC2> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mIdentifier0 = parseIdentifier(tokens);
	if(mIdentifier0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mArgumentSingleItemMaybeInSlotAIdentifier1 = parseArgumentSingleItemMaybeInSlotAIdentifier(tokens);
	if(mArgumentSingleItemMaybeInSlotAIdentifier1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTArgumentSingleItemMaybeInSlotAIdentifierC2",
		mIdentifier0,
		mArgumentSingleItemMaybeInSlotAIdentifier1,
	};
};
// (derivation union) ArgumentOneOrMoreItemsAllowAllMaybeFromSlot => ArgumentItemStacksAllowAllMaybeFromSlot | ArgumentSingleItemAllowAllMaybeFromSlot
const parseArgumentOneOrMoreItemsAllowAllMaybeFromSlot: ParseFunction<ASTArgumentOneOrMoreItemsAllowAllMaybeFromSlot> = (tokens) => {
	let result: ASTArgumentOneOrMoreItemsAllowAllMaybeFromSlot | undefined;
	result = parseArgumentItemStacksAllowAllMaybeFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentSingleItemAllowAllMaybeFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTArgumentOneOrMoreItemsAllowAllMaybeFromSlot = ASTArgumentItemStacksAllowAllMaybeFromSlot | ASTArgumentSingleItemAllowAllMaybeFromSlot;
// (derivation) ArgumentSingleItemAllowAllMaybeFromSlot => Identifier ArgumentSingleItemAllowAllMaybeFromSlotAIdentifier
export const isArgumentSingleItemAllowAllMaybeFromSlot = <T extends {type: string}>(node: T | ASTArgumentSingleItemAllowAllMaybeFromSlot | null): node is ASTArgumentSingleItemAllowAllMaybeFromSlot => Boolean(node && node.type === "ASTArgumentSingleItemAllowAllMaybeFromSlot");
export type ASTArgumentSingleItemAllowAllMaybeFromSlot = {
	readonly type: "ASTArgumentSingleItemAllowAllMaybeFromSlot",
	readonly mIdentifier0: ASTIdentifier,
	readonly mArgumentSingleItemAllowAllMaybeFromSlotAIdentifier1: ASTArgumentSingleItemAllowAllMaybeFromSlotAIdentifier,
};
const parseArgumentSingleItemAllowAllMaybeFromSlot: ParseFunction<ASTArgumentSingleItemAllowAllMaybeFromSlot> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mIdentifier0 = parseIdentifier(tokens);
	if(mIdentifier0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mArgumentSingleItemAllowAllMaybeFromSlotAIdentifier1 = parseArgumentSingleItemAllowAllMaybeFromSlotAIdentifier(tokens);
	if(mArgumentSingleItemAllowAllMaybeFromSlotAIdentifier1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTArgumentSingleItemAllowAllMaybeFromSlot",
		mIdentifier0,
		mArgumentSingleItemAllowAllMaybeFromSlotAIdentifier1,
	};
};
// (derivation union) ArgumentSingleItemAllowAllMaybeFromSlotAIdentifier => ClauseFromSlot | ArgumentSingleItemAllowAllMaybeFromSlot | ArgumentSingleItemAllowAllMaybeFromSlotAIdentifierC1 | Epsilon
const parseArgumentSingleItemAllowAllMaybeFromSlotAIdentifier: ParseFunction<ASTArgumentSingleItemAllowAllMaybeFromSlotAIdentifier> = (tokens) => {
	let result: ASTArgumentSingleItemAllowAllMaybeFromSlotAIdentifier | undefined;
	result = parseClauseFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentSingleItemAllowAllMaybeFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentSingleItemAllowAllMaybeFromSlotAIdentifierC1(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTArgumentSingleItemAllowAllMaybeFromSlotAIdentifier = ASTClauseFromSlot | ASTArgumentSingleItemAllowAllMaybeFromSlot | ASTArgumentSingleItemAllowAllMaybeFromSlotAIdentifierC1 | ASTEpsilon;
// (derivation) ArgumentSingleItemAllowAllMaybeFromSlotAIdentifierC1 => Metadata MaybeClauseFromSlot
export const isArgumentSingleItemAllowAllMaybeFromSlotAIdentifierC1 = <T extends {type: string}>(node: T | ASTArgumentSingleItemAllowAllMaybeFromSlotAIdentifierC1 | null): node is ASTArgumentSingleItemAllowAllMaybeFromSlotAIdentifierC1 => Boolean(node && node.type === "ASTArgumentSingleItemAllowAllMaybeFromSlotAIdentifierC1");
export type ASTArgumentSingleItemAllowAllMaybeFromSlotAIdentifierC1 = {
	readonly type: "ASTArgumentSingleItemAllowAllMaybeFromSlotAIdentifierC1",
	readonly mMetadata0: ASTMetadata,
	readonly mMaybeClauseFromSlot1: ASTMaybeClauseFromSlot,
};
const parseArgumentSingleItemAllowAllMaybeFromSlotAIdentifierC1: ParseFunction<ASTArgumentSingleItemAllowAllMaybeFromSlotAIdentifierC1> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mMetadata0 = parseMetadata(tokens);
	if(mMetadata0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mMaybeClauseFromSlot1 = parseMaybeClauseFromSlot(tokens);
	if(mMaybeClauseFromSlot1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTArgumentSingleItemAllowAllMaybeFromSlotAIdentifierC1",
		mMetadata0,
		mMaybeClauseFromSlot1,
	};
};
// (derivation) ArgumentItemStacksAllowAllMaybeFromSlot => AmountOrAll Identifier ArgumentItemStacksAllowAllMaybeFromSlotAIdentifier
export const isArgumentItemStacksAllowAllMaybeFromSlot = <T extends {type: string}>(node: T | ASTArgumentItemStacksAllowAllMaybeFromSlot | null): node is ASTArgumentItemStacksAllowAllMaybeFromSlot => Boolean(node && node.type === "ASTArgumentItemStacksAllowAllMaybeFromSlot");
export type ASTArgumentItemStacksAllowAllMaybeFromSlot = {
	readonly type: "ASTArgumentItemStacksAllowAllMaybeFromSlot",
	readonly mAmountOrAll0: ASTAmountOrAll,
	readonly mIdentifier1: ASTIdentifier,
	readonly mArgumentItemStacksAllowAllMaybeFromSlotAIdentifier2: ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifier,
};
const parseArgumentItemStacksAllowAllMaybeFromSlot: ParseFunction<ASTArgumentItemStacksAllowAllMaybeFromSlot> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mAmountOrAll0 = parseAmountOrAll(tokens);
	if(mAmountOrAll0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mIdentifier1 = parseIdentifier(tokens);
	if(mIdentifier1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mArgumentItemStacksAllowAllMaybeFromSlotAIdentifier2 = parseArgumentItemStacksAllowAllMaybeFromSlotAIdentifier(tokens);
	if(mArgumentItemStacksAllowAllMaybeFromSlotAIdentifier2 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTArgumentItemStacksAllowAllMaybeFromSlot",
		mAmountOrAll0,
		mIdentifier1,
		mArgumentItemStacksAllowAllMaybeFromSlotAIdentifier2,
	};
};
// (derivation union) ArgumentItemStacksAllowAllMaybeFromSlotAIdentifier => ClauseFromSlot | ArgumentItemStacksAllowAllMaybeFromSlot | ArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC1 | ArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC2 | Epsilon
const parseArgumentItemStacksAllowAllMaybeFromSlotAIdentifier: ParseFunction<ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifier> = (tokens) => {
	let result: ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifier | undefined;
	result = parseClauseFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentItemStacksAllowAllMaybeFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC1(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC2(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifier = ASTClauseFromSlot | ASTArgumentItemStacksAllowAllMaybeFromSlot | ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC1 | ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC2 | ASTEpsilon;
// (derivation) ArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC1 => Metadata ArgumentItemStacksAllowAllMaybeFromSlotAMetadata
export const isArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC1 = <T extends {type: string}>(node: T | ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC1 | null): node is ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC1 => Boolean(node && node.type === "ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC1");
export type ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC1 = {
	readonly type: "ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC1",
	readonly mMetadata0: ASTMetadata,
	readonly mArgumentItemStacksAllowAllMaybeFromSlotAMetadata1: ASTArgumentItemStacksAllowAllMaybeFromSlotAMetadata,
};
const parseArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC1: ParseFunction<ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC1> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mMetadata0 = parseMetadata(tokens);
	if(mMetadata0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mArgumentItemStacksAllowAllMaybeFromSlotAMetadata1 = parseArgumentItemStacksAllowAllMaybeFromSlotAMetadata(tokens);
	if(mArgumentItemStacksAllowAllMaybeFromSlotAMetadata1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC1",
		mMetadata0,
		mArgumentItemStacksAllowAllMaybeFromSlotAMetadata1,
	};
};
// (derivation) ArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC2 => Identifier ArgumentItemStacksAllowAllMaybeFromSlotAIdentifier
export const isArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC2 = <T extends {type: string}>(node: T | ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC2 | null): node is ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC2 => Boolean(node && node.type === "ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC2");
export type ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC2 = {
	readonly type: "ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC2",
	readonly mIdentifier0: ASTIdentifier,
	readonly mArgumentItemStacksAllowAllMaybeFromSlotAIdentifier1: ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifier,
};
const parseArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC2: ParseFunction<ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC2> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mIdentifier0 = parseIdentifier(tokens);
	if(mIdentifier0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mArgumentItemStacksAllowAllMaybeFromSlotAIdentifier1 = parseArgumentItemStacksAllowAllMaybeFromSlotAIdentifier(tokens);
	if(mArgumentItemStacksAllowAllMaybeFromSlotAIdentifier1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTArgumentItemStacksAllowAllMaybeFromSlotAIdentifierC2",
		mIdentifier0,
		mArgumentItemStacksAllowAllMaybeFromSlotAIdentifier1,
	};
};
// (derivation union) ArgumentItemStacksAllowAllMaybeFromSlotAMetadata => ClauseFromSlot | ArgumentItemStacksAllowAllMaybeFromSlot | Epsilon
const parseArgumentItemStacksAllowAllMaybeFromSlotAMetadata: ParseFunction<ASTArgumentItemStacksAllowAllMaybeFromSlotAMetadata> = (tokens) => {
	let result: ASTArgumentItemStacksAllowAllMaybeFromSlotAMetadata | undefined;
	result = parseClauseFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentItemStacksAllowAllMaybeFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTArgumentItemStacksAllowAllMaybeFromSlotAMetadata = ASTClauseFromSlot | ASTArgumentItemStacksAllowAllMaybeFromSlot | ASTEpsilon;
// (derivation union) ArgumentOneOrMoreItemsMaybeFromSlot => ArgumentSingleItemMaybeFromSlot | ArgumentItemStacksMaybeFromSlot
const parseArgumentOneOrMoreItemsMaybeFromSlot: ParseFunction<ASTArgumentOneOrMoreItemsMaybeFromSlot> = (tokens) => {
	let result: ASTArgumentOneOrMoreItemsMaybeFromSlot | undefined;
	result = parseArgumentSingleItemMaybeFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentItemStacksMaybeFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTArgumentOneOrMoreItemsMaybeFromSlot = ASTArgumentSingleItemMaybeFromSlot | ASTArgumentItemStacksMaybeFromSlot;
// (derivation) ArgumentSingleItemMaybeFromSlot => Identifier ArgumentSingleItemMaybeFromSlotAIdentifier
export const isArgumentSingleItemMaybeFromSlot = <T extends {type: string}>(node: T | ASTArgumentSingleItemMaybeFromSlot | null): node is ASTArgumentSingleItemMaybeFromSlot => Boolean(node && node.type === "ASTArgumentSingleItemMaybeFromSlot");
export type ASTArgumentSingleItemMaybeFromSlot = {
	readonly type: "ASTArgumentSingleItemMaybeFromSlot",
	readonly mIdentifier0: ASTIdentifier,
	readonly mArgumentSingleItemMaybeFromSlotAIdentifier1: ASTArgumentSingleItemMaybeFromSlotAIdentifier,
};
const parseArgumentSingleItemMaybeFromSlot: ParseFunction<ASTArgumentSingleItemMaybeFromSlot> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mIdentifier0 = parseIdentifier(tokens);
	if(mIdentifier0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mArgumentSingleItemMaybeFromSlotAIdentifier1 = parseArgumentSingleItemMaybeFromSlotAIdentifier(tokens);
	if(mArgumentSingleItemMaybeFromSlotAIdentifier1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTArgumentSingleItemMaybeFromSlot",
		mIdentifier0,
		mArgumentSingleItemMaybeFromSlotAIdentifier1,
	};
};
// (derivation union) ArgumentSingleItemMaybeFromSlotAIdentifier => ClauseFromSlot | ArgumentSingleItemMaybeFromSlotAIdentifierC1 | ArgumentSingleItemMaybeFromSlot | Epsilon
const parseArgumentSingleItemMaybeFromSlotAIdentifier: ParseFunction<ASTArgumentSingleItemMaybeFromSlotAIdentifier> = (tokens) => {
	let result: ASTArgumentSingleItemMaybeFromSlotAIdentifier | undefined;
	result = parseClauseFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentSingleItemMaybeFromSlotAIdentifierC1(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentSingleItemMaybeFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTArgumentSingleItemMaybeFromSlotAIdentifier = ASTClauseFromSlot | ASTArgumentSingleItemMaybeFromSlotAIdentifierC1 | ASTArgumentSingleItemMaybeFromSlot | ASTEpsilon;
// (derivation) ArgumentSingleItemMaybeFromSlotAIdentifierC1 => Metadata MaybeClauseFromSlot
export const isArgumentSingleItemMaybeFromSlotAIdentifierC1 = <T extends {type: string}>(node: T | ASTArgumentSingleItemMaybeFromSlotAIdentifierC1 | null): node is ASTArgumentSingleItemMaybeFromSlotAIdentifierC1 => Boolean(node && node.type === "ASTArgumentSingleItemMaybeFromSlotAIdentifierC1");
export type ASTArgumentSingleItemMaybeFromSlotAIdentifierC1 = {
	readonly type: "ASTArgumentSingleItemMaybeFromSlotAIdentifierC1",
	readonly mMetadata0: ASTMetadata,
	readonly mMaybeClauseFromSlot1: ASTMaybeClauseFromSlot,
};
const parseArgumentSingleItemMaybeFromSlotAIdentifierC1: ParseFunction<ASTArgumentSingleItemMaybeFromSlotAIdentifierC1> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mMetadata0 = parseMetadata(tokens);
	if(mMetadata0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mMaybeClauseFromSlot1 = parseMaybeClauseFromSlot(tokens);
	if(mMaybeClauseFromSlot1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTArgumentSingleItemMaybeFromSlotAIdentifierC1",
		mMetadata0,
		mMaybeClauseFromSlot1,
	};
};
// (derivation) ArgumentItemStacksMaybeFromSlot => Integer Identifier ArgumentItemStacksMaybeFromSlotAIdentifier
export const isArgumentItemStacksMaybeFromSlot = <T extends {type: string}>(node: T | ASTArgumentItemStacksMaybeFromSlot | null): node is ASTArgumentItemStacksMaybeFromSlot => Boolean(node && node.type === "ASTArgumentItemStacksMaybeFromSlot");
export type ASTArgumentItemStacksMaybeFromSlot = {
	readonly type: "ASTArgumentItemStacksMaybeFromSlot",
	readonly mInteger0: ASTInteger,
	readonly mIdentifier1: ASTIdentifier,
	readonly mArgumentItemStacksMaybeFromSlotAIdentifier2: ASTArgumentItemStacksMaybeFromSlotAIdentifier,
};
const parseArgumentItemStacksMaybeFromSlot: ParseFunction<ASTArgumentItemStacksMaybeFromSlot> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mInteger0 = parseInteger(tokens);
	if(mInteger0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mIdentifier1 = parseIdentifier(tokens);
	if(mIdentifier1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mArgumentItemStacksMaybeFromSlotAIdentifier2 = parseArgumentItemStacksMaybeFromSlotAIdentifier(tokens);
	if(mArgumentItemStacksMaybeFromSlotAIdentifier2 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTArgumentItemStacksMaybeFromSlot",
		mInteger0,
		mIdentifier1,
		mArgumentItemStacksMaybeFromSlotAIdentifier2,
	};
};
// (derivation union) ArgumentItemStacksMaybeFromSlotAIdentifier => ClauseFromSlot | ArgumentItemStacksMaybeFromSlotAIdentifierC1 | ArgumentItemStacksMaybeFromSlotAIdentifierC2 | ArgumentItemStacksMaybeFromSlot | Epsilon
const parseArgumentItemStacksMaybeFromSlotAIdentifier: ParseFunction<ASTArgumentItemStacksMaybeFromSlotAIdentifier> = (tokens) => {
	let result: ASTArgumentItemStacksMaybeFromSlotAIdentifier | undefined;
	result = parseClauseFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentItemStacksMaybeFromSlotAIdentifierC1(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentItemStacksMaybeFromSlotAIdentifierC2(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentItemStacksMaybeFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTArgumentItemStacksMaybeFromSlotAIdentifier = ASTClauseFromSlot | ASTArgumentItemStacksMaybeFromSlotAIdentifierC1 | ASTArgumentItemStacksMaybeFromSlotAIdentifierC2 | ASTArgumentItemStacksMaybeFromSlot | ASTEpsilon;
// (derivation) ArgumentItemStacksMaybeFromSlotAIdentifierC1 => Metadata ArgumentItemStacksMaybeFromSlotAMetadata
export const isArgumentItemStacksMaybeFromSlotAIdentifierC1 = <T extends {type: string}>(node: T | ASTArgumentItemStacksMaybeFromSlotAIdentifierC1 | null): node is ASTArgumentItemStacksMaybeFromSlotAIdentifierC1 => Boolean(node && node.type === "ASTArgumentItemStacksMaybeFromSlotAIdentifierC1");
export type ASTArgumentItemStacksMaybeFromSlotAIdentifierC1 = {
	readonly type: "ASTArgumentItemStacksMaybeFromSlotAIdentifierC1",
	readonly mMetadata0: ASTMetadata,
	readonly mArgumentItemStacksMaybeFromSlotAMetadata1: ASTArgumentItemStacksMaybeFromSlotAMetadata,
};
const parseArgumentItemStacksMaybeFromSlotAIdentifierC1: ParseFunction<ASTArgumentItemStacksMaybeFromSlotAIdentifierC1> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mMetadata0 = parseMetadata(tokens);
	if(mMetadata0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mArgumentItemStacksMaybeFromSlotAMetadata1 = parseArgumentItemStacksMaybeFromSlotAMetadata(tokens);
	if(mArgumentItemStacksMaybeFromSlotAMetadata1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTArgumentItemStacksMaybeFromSlotAIdentifierC1",
		mMetadata0,
		mArgumentItemStacksMaybeFromSlotAMetadata1,
	};
};
// (derivation) ArgumentItemStacksMaybeFromSlotAIdentifierC2 => Identifier ArgumentItemStacksMaybeFromSlotAIdentifier
export const isArgumentItemStacksMaybeFromSlotAIdentifierC2 = <T extends {type: string}>(node: T | ASTArgumentItemStacksMaybeFromSlotAIdentifierC2 | null): node is ASTArgumentItemStacksMaybeFromSlotAIdentifierC2 => Boolean(node && node.type === "ASTArgumentItemStacksMaybeFromSlotAIdentifierC2");
export type ASTArgumentItemStacksMaybeFromSlotAIdentifierC2 = {
	readonly type: "ASTArgumentItemStacksMaybeFromSlotAIdentifierC2",
	readonly mIdentifier0: ASTIdentifier,
	readonly mArgumentItemStacksMaybeFromSlotAIdentifier1: ASTArgumentItemStacksMaybeFromSlotAIdentifier,
};
const parseArgumentItemStacksMaybeFromSlotAIdentifierC2: ParseFunction<ASTArgumentItemStacksMaybeFromSlotAIdentifierC2> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mIdentifier0 = parseIdentifier(tokens);
	if(mIdentifier0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mArgumentItemStacksMaybeFromSlotAIdentifier1 = parseArgumentItemStacksMaybeFromSlotAIdentifier(tokens);
	if(mArgumentItemStacksMaybeFromSlotAIdentifier1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTArgumentItemStacksMaybeFromSlotAIdentifierC2",
		mIdentifier0,
		mArgumentItemStacksMaybeFromSlotAIdentifier1,
	};
};
// (derivation union) ArgumentItemStacksMaybeFromSlotAMetadata => ClauseFromSlot | ArgumentItemStacksMaybeFromSlot | Epsilon
const parseArgumentItemStacksMaybeFromSlotAMetadata: ParseFunction<ASTArgumentItemStacksMaybeFromSlotAMetadata> = (tokens) => {
	let result: ASTArgumentItemStacksMaybeFromSlotAMetadata | undefined;
	result = parseClauseFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseArgumentItemStacksMaybeFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTArgumentItemStacksMaybeFromSlotAMetadata = ASTClauseFromSlot | ASTArgumentItemStacksMaybeFromSlot | ASTEpsilon;
// (derivation union) MaybeClauseFromSlot => ClauseFromSlot | Epsilon
const parseMaybeClauseFromSlot: ParseFunction<ASTMaybeClauseFromSlot> = (tokens) => {
	let result: ASTMaybeClauseFromSlot | undefined;
	result = parseClauseFromSlot(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTMaybeClauseFromSlot = ASTClauseFromSlot | ASTEpsilon;
// (derivation) ClauseFromSlot => <from> LiteralSlot Integer
export const isClauseFromSlot = <T extends {type: string}>(node: T | ASTClauseFromSlot | null): node is ASTClauseFromSlot => Boolean(node && node.type === "ASTClauseFromSlot");
export type ASTClauseFromSlot = {
	readonly type: "ASTClauseFromSlot",
	readonly literal0: readonly [number, number],
	readonly mLiteralSlot1: ASTLiteralSlot,
	readonly mInteger2: ASTInteger,
};
const parseClauseFromSlot: ParseFunction<ASTClauseFromSlot> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "from") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mLiteralSlot1 = parseLiteralSlot(tokens);
	if(mLiteralSlot1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mInteger2 = parseInteger(tokens);
	if(mInteger2 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTClauseFromSlot",
		literal0,
		mLiteralSlot1,
		mInteger2,
	};
};
// (derivation) ClauseInSlot => <in> LiteralSlot Integer
export const isClauseInSlot = <T extends {type: string}>(node: T | ASTClauseInSlot | null): node is ASTClauseInSlot => Boolean(node && node.type === "ASTClauseInSlot");
export type ASTClauseInSlot = {
	readonly type: "ASTClauseInSlot",
	readonly literal0: readonly [number, number],
	readonly mLiteralSlot1: ASTLiteralSlot,
	readonly mInteger2: ASTInteger,
};
const parseClauseInSlot: ParseFunction<ASTClauseInSlot> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "in") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mLiteralSlot1 = parseLiteralSlot(tokens);
	if(mLiteralSlot1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mInteger2 = parseInteger(tokens);
	if(mInteger2 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTClauseInSlot",
		literal0,
		mLiteralSlot1,
		mInteger2,
	};
};
// (derivation union) MaybeClauseSaveTarget => ClauseSaveTarget | Epsilon
const parseMaybeClauseSaveTarget: ParseFunction<ASTMaybeClauseSaveTarget> = (tokens) => {
	let result: ASTMaybeClauseSaveTarget | undefined;
	result = parseClauseSaveTarget(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTMaybeClauseSaveTarget = ASTClauseSaveTarget | ASTEpsilon;
// (derivation) ClauseSaveTarget => <as> OneOrMoreIdentifiers
export const isClauseSaveTarget = <T extends {type: string}>(node: T | ASTClauseSaveTarget | null): node is ASTClauseSaveTarget => Boolean(node && node.type === "ASTClauseSaveTarget");
export type ASTClauseSaveTarget = {
	readonly type: "ASTClauseSaveTarget",
	readonly literal0: readonly [number, number],
	readonly mOneOrMoreIdentifiers1: ASTOneOrMoreIdentifiers,
};
const parseClauseSaveTarget: ParseFunction<ASTClauseSaveTarget> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "as") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mOneOrMoreIdentifiers1 = parseOneOrMoreIdentifiers(tokens);
	if(mOneOrMoreIdentifiers1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTClauseSaveTarget",
		literal0,
		mOneOrMoreIdentifiers1,
	};
};
// (derivation union) ZeroOrMoreItems => SingleItem | ItemStackPrime
const parseZeroOrMoreItems: ParseFunction<ASTZeroOrMoreItems> = (tokens) => {
	let result: ASTZeroOrMoreItems | undefined;
	result = parseSingleItem(tokens);
	if(result !== ParseResultFail) return result;
	result = parseItemStackPrime(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTZeroOrMoreItems = ASTSingleItem | ASTItemStackPrime;
// (derivation union) OneOrMoreItems => SingleItem | OneOrMoreItemStacks
const parseOneOrMoreItems: ParseFunction<ASTOneOrMoreItems> = (tokens) => {
	let result: ASTOneOrMoreItems | undefined;
	result = parseSingleItem(tokens);
	if(result !== ParseResultFail) return result;
	result = parseOneOrMoreItemStacks(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTOneOrMoreItems = ASTSingleItem | ASTOneOrMoreItemStacks;
// (derivation) OneOrMoreItemStacks => ItemStack ItemStackPrime
export const isOneOrMoreItemStacks = <T extends {type: string}>(node: T | ASTOneOrMoreItemStacks | null): node is ASTOneOrMoreItemStacks => Boolean(node && node.type === "ASTOneOrMoreItemStacks");
export type ASTOneOrMoreItemStacks = {
	readonly type: "ASTOneOrMoreItemStacks",
	readonly mItemStack0: ASTItemStack,
	readonly mItemStackPrime1: ASTItemStackPrime,
};
const parseOneOrMoreItemStacks: ParseFunction<ASTOneOrMoreItemStacks> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mItemStack0 = parseItemStack(tokens);
	if(mItemStack0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mItemStackPrime1 = parseItemStackPrime(tokens);
	if(mItemStackPrime1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTOneOrMoreItemStacks",
		mItemStack0,
		mItemStackPrime1,
	};
};
// (derivation) ItemStack => Integer SingleItem
export const isItemStack = <T extends {type: string}>(node: T | ASTItemStack | null): node is ASTItemStack => Boolean(node && node.type === "ASTItemStack");
export type ASTItemStack = {
	readonly type: "ASTItemStack",
	readonly mInteger0: ASTInteger,
	readonly mSingleItem1: ASTSingleItem,
};
const parseItemStack: ParseFunction<ASTItemStack> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mInteger0 = parseInteger(tokens);
	if(mInteger0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mSingleItem1 = parseSingleItem(tokens);
	if(mSingleItem1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTItemStack",
		mInteger0,
		mSingleItem1,
	};
};
// (derivation union) ItemStackPrime => OneOrMoreItemStacks | Epsilon
const parseItemStackPrime: ParseFunction<ASTItemStackPrime> = (tokens) => {
	let result: ASTItemStackPrime | undefined;
	result = parseOneOrMoreItemStacks(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTItemStackPrime = ASTOneOrMoreItemStacks | ASTEpsilon;
// (derivation union) AmountOrAll => Integer | LiteralAll
const parseAmountOrAll: ParseFunction<ASTAmountOrAll> = (tokens) => {
	let result: ASTAmountOrAll | undefined;
	result = parseInteger(tokens);
	if(result !== ParseResultFail) return result;
	result = parseLiteralAll(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTAmountOrAll = ASTInteger | ASTLiteralAll;
// (derivation) SingleItem => OneOrMoreIdentifiers MaybeMetadata
export const isSingleItem = <T extends {type: string}>(node: T | ASTSingleItem | null): node is ASTSingleItem => Boolean(node && node.type === "ASTSingleItem");
export type ASTSingleItem = {
	readonly type: "ASTSingleItem",
	readonly mOneOrMoreIdentifiers0: ASTOneOrMoreIdentifiers,
	readonly mMaybeMetadata1: ASTMaybeMetadata,
};
const parseSingleItem: ParseFunction<ASTSingleItem> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mOneOrMoreIdentifiers0 = parseOneOrMoreIdentifiers(tokens);
	if(mOneOrMoreIdentifiers0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mMaybeMetadata1 = parseMaybeMetadata(tokens);
	if(mMaybeMetadata1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTSingleItem",
		mOneOrMoreIdentifiers0,
		mMaybeMetadata1,
	};
};
// (derivation union) IdentifierPrime => OneOrMoreIdentifiers | Epsilon
const parseIdentifierPrime: ParseFunction<ASTIdentifierPrime> = (tokens) => {
	let result: ASTIdentifierPrime | undefined;
	result = parseOneOrMoreIdentifiers(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTIdentifierPrime = ASTOneOrMoreIdentifiers | ASTEpsilon;
// (derivation) OneOrMoreIdentifiers => Identifier IdentifierPrime
export const isOneOrMoreIdentifiers = <T extends {type: string}>(node: T | ASTOneOrMoreIdentifiers | null): node is ASTOneOrMoreIdentifiers => Boolean(node && node.type === "ASTOneOrMoreIdentifiers");
export type ASTOneOrMoreIdentifiers = {
	readonly type: "ASTOneOrMoreIdentifiers",
	readonly mIdentifier0: ASTIdentifier,
	readonly mIdentifierPrime1: ASTIdentifierPrime,
};
const parseOneOrMoreIdentifiers: ParseFunction<ASTOneOrMoreIdentifiers> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mIdentifier0 = parseIdentifier(tokens);
	if(mIdentifier0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mIdentifierPrime1 = parseIdentifierPrime(tokens);
	if(mIdentifierPrime1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTOneOrMoreIdentifiers",
		mIdentifier0,
		mIdentifierPrime1,
	};
};
// (derivation union) MaybeMetadata => Metadata | Epsilon
const parseMaybeMetadata: ParseFunction<ASTMaybeMetadata> = (tokens) => {
	let result: ASTMaybeMetadata | undefined;
	result = parseMetadata(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTMaybeMetadata = ASTMetadata | ASTEpsilon;
// (derivation) Metadata => <[> KeyValuePair KeyValuePairPrime <]>
export const isMetadata = <T extends {type: string}>(node: T | ASTMetadata | null): node is ASTMetadata => Boolean(node && node.type === "ASTMetadata");
export type ASTMetadata = {
	readonly type: "ASTMetadata",
	readonly literal0: readonly [number, number],
	readonly mKeyValuePair1: ASTKeyValuePair,
	readonly mKeyValuePairPrime2: ASTKeyValuePairPrime,
	readonly literal3: readonly [number, number],
};
const parseMetadata: ParseFunction<ASTMetadata> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "[") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mKeyValuePair1 = parseKeyValuePair(tokens);
	if(mKeyValuePair1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mKeyValuePairPrime2 = parseKeyValuePairPrime(tokens);
	if(mKeyValuePairPrime2 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== "]") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal3 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	tokens.pop();
	return {
		type: "ASTMetadata",
		literal0,
		mKeyValuePair1,
		mKeyValuePairPrime2,
		literal3,
	};
};
// (derivation) KeyValuePair => Identifier Value
export const isKeyValuePair = <T extends {type: string}>(node: T | ASTKeyValuePair | null): node is ASTKeyValuePair => Boolean(node && node.type === "ASTKeyValuePair");
export type ASTKeyValuePair = {
	readonly type: "ASTKeyValuePair",
	readonly mIdentifier0: ASTIdentifier,
	readonly mValue1: ASTValue,
};
const parseKeyValuePair: ParseFunction<ASTKeyValuePair> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mIdentifier0 = parseIdentifier(tokens);
	if(mIdentifier0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mValue1 = parseValue(tokens);
	if(mValue1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTKeyValuePair",
		mIdentifier0,
		mValue1,
	};
};
// (derivation union) Value => SpecifiedValue | Epsilon
const parseValue: ParseFunction<ASTValue> = (tokens) => {
	let result: ASTValue | undefined;
	result = parseSpecifiedValue(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTValue = ASTSpecifiedValue | ASTEpsilon;
// (derivation) SpecifiedValue => ValueSpecifier ValueValue
export const isSpecifiedValue = <T extends {type: string}>(node: T | ASTSpecifiedValue | null): node is ASTSpecifiedValue => Boolean(node && node.type === "ASTSpecifiedValue");
export type ASTSpecifiedValue = {
	readonly type: "ASTSpecifiedValue",
	readonly mValueSpecifier0: ASTValueSpecifier,
	readonly mValueValue1: ASTValueValue,
};
const parseSpecifiedValue: ParseFunction<ASTSpecifiedValue> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	const mValueSpecifier0 = parseValueSpecifier(tokens);
	if(mValueSpecifier0 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mValueValue1 = parseValueValue(tokens);
	if(mValueValue1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTSpecifiedValue",
		mValueSpecifier0,
		mValueValue1,
	};
};
// (literal union) ValueSpecifier => <=> | <:>
export const isValueSpecifier = <T extends {type: string}>(node: T | ASTValueSpecifier | null): node is ASTValueSpecifier => Boolean(node && node.type === "ASTValueSpecifier");
export type ASTValueSpecifier = {
	type: "ASTValueSpecifier";
	range: [number, number];
};
const parseValueSpecifier: ParseFunction<ASTValueSpecifier> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === "="){
		tokens.pop();
		return {
			type: "ASTValueSpecifier",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) === ":"){
		tokens.pop();
		return {
			type: "ASTValueSpecifier",
			range: [ rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end ]
		};
	}
		tokens.restore();
	tokens.pop();
	return ParseResultFail;
};
// (derivation union) ValueValue => Integer | Identifier
const parseValueValue: ParseFunction<ASTValueValue> = (tokens) => {
	let result: ASTValueValue | undefined;
	result = parseInteger(tokens);
	if(result !== ParseResultFail) return result;
	result = parseIdentifier(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTValueValue = ASTInteger | ASTIdentifier;
// (derivation union) KeyValuePairPrime => KeyValuePairPrimeC1 | Epsilon
const parseKeyValuePairPrime: ParseFunction<ASTKeyValuePairPrime> = (tokens) => {
	let result: ASTKeyValuePairPrime | undefined;
	result = parseKeyValuePairPrimeC1(tokens);
	if(result !== ParseResultFail) return result;
	result = parseEpsilon(tokens);
	if(result !== ParseResultFail) return result;
	return ParseResultFail;
};
export type ASTKeyValuePairPrime = ASTKeyValuePairPrimeC1 | ASTEpsilon;
// (derivation) KeyValuePairPrimeC1 => <,> KeyValuePair KeyValuePairPrime
export const isKeyValuePairPrimeC1 = <T extends {type: string}>(node: T | ASTKeyValuePairPrimeC1 | null): node is ASTKeyValuePairPrimeC1 => Boolean(node && node.type === "ASTKeyValuePairPrimeC1");
export type ASTKeyValuePairPrimeC1 = {
	readonly type: "ASTKeyValuePairPrimeC1",
	readonly literal0: readonly [number, number],
	readonly mKeyValuePair1: ASTKeyValuePair,
	readonly mKeyValuePairPrime2: ASTKeyValuePairPrime,
};
const parseKeyValuePairPrimeC1: ParseFunction<ASTKeyValuePairPrimeC1> = (tokens) => {
	let rangeTokens: Token[];
	tokens.push();
	rangeTokens = [];
	if(tokens.consume(rangeTokens) !== ",") {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const literal0 = [rangeTokens[0].start, rangeTokens[rangeTokens.length-1].end] as const;
	const mKeyValuePair1 = parseKeyValuePair(tokens);
	if(mKeyValuePair1 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	const mKeyValuePairPrime2 = parseKeyValuePairPrime(tokens);
	if(mKeyValuePairPrime2 === ParseResultFail) {
		tokens.restore();
		tokens.pop();
		return ParseResultFail;
	}
	tokens.pop();
	return {
		type: "ASTKeyValuePairPrimeC1",
		literal0,
		mKeyValuePair1,
		mKeyValuePairPrime2,
	};
};
export const parse = parseTarget;
