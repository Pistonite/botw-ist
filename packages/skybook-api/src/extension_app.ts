import type { Result } from "@pistonite/pure/result";
import type { WxPromise } from "@pistonite/workex";

import type { Diagnostic, ItemSearchResult } from "./types.ts";
import type {
    InvView_Gdt,
    InvView_Overworld,
    InvView_PouchList,
    MaybeAborted,
    RuntimeViewError,
} from "./native";

/**
 * API implemented by the application and called by the extension.
 */
export interface ExtensionApp {
    /** Get the current simulator script. */
    getScript(): WxPromise<string>;

    /**
     * Set the simulator script.
     *
     * This will trigger a rerun of the simulation using the new script
     *
     * Position is the current cursor position in the script as
     * a character offset (not byte offset) and is 0-based.
     */
    setScript(script: string, position: number): WxPromise<void>;

    /**
     * Resolve an item from a query
     *
     * If localized is true, treat the query as a localized item search query (i.e. "[tag:]words"),
     * otherwise, treat it as an identifier search query.)
     *
     * A localized error maybe returned if the query is invalid. However,
     * even when there is no error, the search result could be empty.
     */
    resolveItem(
        query: string,
        localized: boolean,
        limit: number,
    ): WxPromise<Result<ItemSearchResult[], string>>;

    /**
     * Invoke the parser for the script and get the diagnostics.
     */
    provideParserDiagnostics(script: string): WxPromise<Diagnostic[]>;

    /**
     * Get the semantic tokens for the script in the range.
     *
     * The output is triples of [start, length, tokenType].
     *
     * The offsets in both inputs and outputs should be character offsets, not byte offsets.
     * (Note this is different from Runtime.getSemanticTokens)
     */
    provideSemanticTokens(
        script: string,
        start: number,
        end: number,
    ): WxPromise<Uint32Array>;

    /**
     * Get the step index from character position
     *
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    getStepFromCharPos(
        script: string | undefined,
        charPos: number | undefined,
    ): WxPromise<number>;

    /**
     * Get the starting byte positions for each step in the script
     *
     * Note that the positions are in bytes. Use getStepCharPositions
     * if you need the character positions.
     */
    getStepBytePositions(script: string): WxPromise<Uint32Array>;
    getStepCharPositions(script: string): WxPromise<Uint32Array>;

    /**
     * Generate new task IDs based on the unique Id.
     *
     * The previous batch generated by the same unique ID will also
     * be returned, which can be used to cancel previous tasks.
     *
     * In case of scheduling issues, make sure the new task starts running
     * before canceling the previous one
     */
    requestNewTaskIds(uniqueId: string, count: number): WxPromise<string[]>;

    /** Cancel previous requests made to the runtime */
    cancelRuntimeTasks(taskId: string[]): WxPromise<void>;

    /**
     * Get the diagnostics from running the script.
     */
    provideRuntimeDiagnostics(
        script: string,
        taskId: string,
    ): WxPromise<MaybeAborted<Diagnostic[]>>;

    /**
     * Provide only diagnostics from running the script up to and including
     * the step that contains the bytePos.
     */
    providePartialRuntimeDiagnostics(
        script: string,
        taskId: string,
        bytePos: number,
    ): WxPromise<MaybeAborted<Diagnostic[]>>;

    /**
     * Get the pouch (visible inventory) state.
     *
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    getPouchList(
        taskId: string,
        script: string | undefined,
        charPos: number | undefined,
    ): WxPromise<MaybeAborted<Result<InvView_PouchList, RuntimeViewError>>>;

    /**
     * Get the Game Data inventory state at the character position `charPos` in the script
     *
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    getGdtInventory(
        taskId: string,
        script: string | undefined,
        charPos: number | undefined,
    ): WxPromise<MaybeAborted<Result<InvView_Gdt, RuntimeViewError>>>;

    /**
     * Get the overworld state at the character position `charPos` in the script
     *
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    getOverworldItems(
        taskId: string,
        script: string | undefined,
        charPos: number | undefined,
    ): WxPromise<MaybeAborted<Result<InvView_Overworld, RuntimeViewError>>>;

    /**
     * Get the rendered crash report at the character position `charPos` in the script
     *
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    getCrashInfo(
        taskId: string,
        script: string | undefined,
        charPos: number | undefined,
    ): WxPromise<MaybeAborted<string>>;

    /**
     * Get the list of save names at the character position `charPos` in the script.
     * Manual save is not included in the list.
     *
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    getSaveNames(
        taskId: string,
        script: string | undefined,
        charPos: number | undefined,
    ): WxPromise<MaybeAborted<string[]>>;

    /**
     * Get the GDT inventory of a named or manual save at the character position `charPos` in the script.
     * Use `undefined` as the name for manual save.
     *
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    getSaveInventory(
        taskId: string,
        script: string | undefined,
        charPos: number | undefined,
        name: string | undefined,
    ): WxPromise<MaybeAborted<Result<InvView_Gdt, RuntimeViewError>>>;
}
