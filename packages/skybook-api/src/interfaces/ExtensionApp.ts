/*
 * This file is generated by the workex CLI Tool
 *
 * Please visit https://workex.pistonite.dev for more information
 */

import type { ExtensionApp } from "../ExtensionApp.ts";

import type { Result } from "@pistonite/pure/result";
import type { WxPromise, WxBusRecvHandler, WxProtocolBoundSender } from "@pistonite/workex";
import type { Diagnostic, ItemSearchResult } from "../types.ts";

/*
 * These generated implementations are used internally by other generated code.
 * They should not be used directly!
 */

/**
 * API implemented by the application and called by the extension.
 */
export class _wxSenderImpl implements ExtensionApp {
    private sender: WxProtocolBoundSender

    constructor(sender: WxProtocolBoundSender) {
        this.sender = sender
    }

    /**
     * Cancel a previous request for runtime diagnostics.
     */
    public cancelRuntimeDiagnosticsRequest( taskId: string ): WxPromise<void> {
        return this.sender.sendVoid(20 /* ExtensionApp.cancelRuntimeDiagnosticsRequest */, [ taskId ]);
    }

    /**
     * Get the current simulator script.
     */
    public getScript( ): WxPromise<string> {
        return this.sender.send<string>(21 /* ExtensionApp.getScript */, [ ]);
    }

    /**
     * Invoke the parser for the script and get the diagnostics.
     */
    public provideParserDiagnostics( script: string ): WxPromise<Diagnostic[]> {
        return this.sender.send<Diagnostic[]>(22 /* ExtensionApp.provideParserDiagnostics */, [ script ]);
    }

    /**
     * Get the diagnostics from running the script.
     * 
     * The taskId should be a UUID, which can be used to cancel the diagnostic
     * request if it's no longer needed to save CPU resource
     */
    public provideRuntimeDiagnostics( script: string, taskId: string ): WxPromise<Diagnostic[]> {
        return this.sender.send<Diagnostic[]>(23 /* ExtensionApp.provideRuntimeDiagnostics */, [ script, taskId ]);
    }

    /**
     * Get the semantic tokens for the script in the range.
     * 
     * The output is triples of [start, length, tokenType].
     * 
     * The offsets in both inputs and outputs should be character offsets, not byte offsets.
     * (Note this is different from Runtime.getSemanticTokens)
     */
    public provideSemanticTokens( script: string, start: number, end: number ): WxPromise<Uint32Array> {
        return this.sender.send<Uint32Array>(24 /* ExtensionApp.provideSemanticTokens */, [ script, start, end ]);
    }

    /**
     * Resolve an item from a query
     * 
     * If localized is true, treat the query as a localized item search query (i.e. "[tag:]words"),
     * otherwise, treat it as an identifier search query.)
     * 
     * A localized error maybe returned if the query is invalid. However,
     * even when there is no error, the search result could be empty.
     */
    public resolveItem( query: string, localized: boolean, limit: number ): WxPromise<Result<ItemSearchResult[], string>> {
        return this.sender.send<Result<ItemSearchResult[], string>>(25 /* ExtensionApp.resolveItem */, [ query, localized, limit ]);
    }

    /**
     * Set the simulator script.
     * 
     * This will trigger a rerun of the simulation using the new script
     * 
     * Position is the current cursor position in the script as
     * a character offset (not byte offset) and is 0-based.
     */
    public setScript( script: string, position: number ): WxPromise<void> {
        return this.sender.sendVoid(26 /* ExtensionApp.setScript */, [ script, position ]);
    }
}

/**
 * API implemented by the application and called by the extension.
 */
export const _wxRecverImpl = (handler: ExtensionApp): WxBusRecvHandler => {
    return ((fId, args: any[]) => { switch (fId) {
        case 20 /* ExtensionApp.cancelRuntimeDiagnosticsRequest */: {
            const [ a0 ] = args;
            return handler.cancelRuntimeDiagnosticsRequest( a0 );
        }
        case 21 /* ExtensionApp.getScript */: {
            return handler.getScript();
        }
        case 22 /* ExtensionApp.provideParserDiagnostics */: {
            const [ a0 ] = args;
            return handler.provideParserDiagnostics( a0 );
        }
        case 23 /* ExtensionApp.provideRuntimeDiagnostics */: {
            const [ a0, a1 ] = args;
            return handler.provideRuntimeDiagnostics( a0, a1 );
        }
        case 24 /* ExtensionApp.provideSemanticTokens */: {
            const [ a0, a1, a2 ] = args;
            return handler.provideSemanticTokens( a0, a1, a2 );
        }
        case 25 /* ExtensionApp.resolveItem */: {
            const [ a0, a1, a2 ] = args;
            return handler.resolveItem( a0, a1, a2 );
        }
        case 26 /* ExtensionApp.setScript */: {
            const [ a0, a1 ] = args;
            return handler.setScript( a0, a1 );
        }
    } return Promise.resolve({ err: { code: "UnknownFunction" } }); }) as WxBusRecvHandler;
};