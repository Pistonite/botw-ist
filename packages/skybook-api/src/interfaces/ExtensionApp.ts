/*
 * This file is generated by the workex CLI Tool
 *
 * Please visit https://workex.pistonite.dev for more information
 */

import type { ExtensionApp } from "../extension_app.ts";

import type { Result } from "@pistonite/pure/result";
import type { WxPromise, WxBusRecvHandler, WxProtocolBoundSender } from "@pistonite/workex";
import type { Diagnostic, ItemSearchResult } from "../types.ts";
import type { InvView_Gdt, InvView_Overworld, InvView_PouchList, MaybeAborted, RuntimeViewError } from "../native";

/*
 * These generated implementations are used internally by other generated code.
 * They should not be used directly!
 */

/**
 * API implemented by the application and called by the extension.
 */
export class _wxSenderImpl implements ExtensionApp {
    private sender: WxProtocolBoundSender

    constructor(sender: WxProtocolBoundSender) {
        this.sender = sender
    }

    /**
     * Cancel previous requests made to the runtime
     */
    public cancelRuntimeTasks( taskId: string[] ): WxPromise<void> {
        return this.sender.sendVoid(21 /* ExtensionApp.cancelRuntimeTasks */, [ taskId ]);
    }

    /**
     * Get the rendered crash report at the byte offset `pos` in the script
     * 
     * Pass in `undefined` to use the current state of the application.
     * However, if `script` is not `undefined` and `pos` is `undefined`,
     * pos defaults to 0
     */
    public getCrashInfo( taskId: string, script: string | undefined, charPos: number | undefined ): WxPromise<MaybeAborted<string>> {
        return this.sender.send<MaybeAborted<string>>(22 /* ExtensionApp.getCrashInfo */, [ taskId, script, charPos ]);
    }

    /**
     * Get the Game Data inventory state at the byte offset `pos` in the script
     * 
     * Pass in `undefined` to use the current state of the application.
     * However, if `script` is not `undefined` and `pos` is `undefined`,
     * pos defaults to 0
     */
    public getGdtInventory( taskId: string, script: string | undefined, charPos: number | undefined ): WxPromise<MaybeAborted<Result<InvView_Gdt, RuntimeViewError>>> {
        return this.sender.send<MaybeAborted<Result<InvView_Gdt, RuntimeViewError>>>(23 /* ExtensionApp.getGdtInventory */, [ taskId, script, charPos ]);
    }

    /**
     * Get the overworld state at the byte offset `pos` in the script
     * 
     * Pass in `undefined` to use the current state of the application.
     * However, if `script` is not `undefined` and `pos` is `undefined`,
     * pos defaults to 0
     */
    public getOverworldItems( taskId: string, script: string | undefined, charPos: number | undefined ): WxPromise<MaybeAborted<Result<InvView_Overworld, RuntimeViewError>>> {
        return this.sender.send<MaybeAborted<Result<InvView_Overworld, RuntimeViewError>>>(24 /* ExtensionApp.getOverworldItems */, [ taskId, script, charPos ]);
    }

    /**
     * Get the pouch (visible inventory) state.
     * 
     * Pass in `undefined` to use the current state of the application.
     * However, if `script` is not `undefined` and `pos` is `undefined`,
     * pos defaults to 0
     */
    public getPouchList( taskId: string, script: string | undefined, charPos: number | undefined ): WxPromise<MaybeAborted<Result<InvView_PouchList, RuntimeViewError>>> {
        return this.sender.send<MaybeAborted<Result<InvView_PouchList, RuntimeViewError>>>(25 /* ExtensionApp.getPouchList */, [ taskId, script, charPos ]);
    }

    /**
     * Get the current simulator script.
     */
    public getScript( ): WxPromise<string> {
        return this.sender.send<string>(26 /* ExtensionApp.getScript */, [ ]);
    }

    /**
     * Get the starting byte positions for each step in the script
     * 
     * Note that the positions are in bytes. Use getStepCharPositions
     * if you need the character positions.
     */
    public getStepBytePositions( script: string ): WxPromise<Uint32Array> {
        return this.sender.send<Uint32Array>(27 /* ExtensionApp.getStepBytePositions */, [ script ]);
    }

    public getStepCharPositions( script: string ): WxPromise<Uint32Array> {
        return this.sender.send<Uint32Array>(28 /* ExtensionApp.getStepCharPositions */, [ script ]);
    }

    /**
     * Invoke the parser for the script and get the diagnostics.
     */
    public provideParserDiagnostics( script: string ): WxPromise<Diagnostic[]> {
        return this.sender.send<Diagnostic[]>(29 /* ExtensionApp.provideParserDiagnostics */, [ script ]);
    }

    /**
     * Provide only diagnostics from running the script up to and including
     * the step that contains the bytePos.
     */
    public providePartialRuntimeDiagnostics( script: string, taskId: string, bytePos: number ): WxPromise<MaybeAborted<Diagnostic[]>> {
        return this.sender.send<MaybeAborted<Diagnostic[]>>(30 /* ExtensionApp.providePartialRuntimeDiagnostics */, [ script, taskId, bytePos ]);
    }

    /**
     * Get the diagnostics from running the script.
     */
    public provideRuntimeDiagnostics( script: string, taskId: string ): WxPromise<MaybeAborted<Diagnostic[]>> {
        return this.sender.send<MaybeAborted<Diagnostic[]>>(31 /* ExtensionApp.provideRuntimeDiagnostics */, [ script, taskId ]);
    }

    /**
     * Get the semantic tokens for the script in the range.
     * 
     * The output is triples of [start, length, tokenType].
     * 
     * The offsets in both inputs and outputs should be character offsets, not byte offsets.
     * (Note this is different from Runtime.getSemanticTokens)
     */
    public provideSemanticTokens( script: string, start: number, end: number ): WxPromise<Uint32Array> {
        return this.sender.send<Uint32Array>(32 /* ExtensionApp.provideSemanticTokens */, [ script, start, end ]);
    }

    /**
     * Generate new task IDs based on the unique Id.
     * 
     * The previous batch generated by the same unique ID will also
     * be returned, which can be used to cancel previous tasks.
     * 
     * In case of scheduling issues, make sure the new task starts running
     * before canceling the previous one
     */
    public requestNewTaskIds( uniqueId: string, count: number ): WxPromise<string[]> {
        return this.sender.send<string[]>(33 /* ExtensionApp.requestNewTaskIds */, [ uniqueId, count ]);
    }

    /**
     * Resolve an item from a query
     * 
     * If localized is true, treat the query as a localized item search query (i.e. "[tag:]words"),
     * otherwise, treat it as an identifier search query.)
     * 
     * A localized error maybe returned if the query is invalid. However,
     * even when there is no error, the search result could be empty.
     */
    public resolveItem( query: string, localized: boolean, limit: number ): WxPromise<Result<ItemSearchResult[], string>> {
        return this.sender.send<Result<ItemSearchResult[], string>>(34 /* ExtensionApp.resolveItem */, [ query, localized, limit ]);
    }

    /**
     * Set the simulator script.
     * 
     * This will trigger a rerun of the simulation using the new script
     * 
     * Position is the current cursor position in the script as
     * a character offset (not byte offset) and is 0-based.
     */
    public setScript( script: string, position: number ): WxPromise<void> {
        return this.sender.sendVoid(35 /* ExtensionApp.setScript */, [ script, position ]);
    }
}

/**
 * API implemented by the application and called by the extension.
 */
export const _wxRecverImpl = (handler: ExtensionApp): WxBusRecvHandler => {
    return ((fId, args: any[]) => { switch (fId) {
        case 21 /* ExtensionApp.cancelRuntimeTasks */: {
            const [ a0 ] = args;
            return handler.cancelRuntimeTasks( a0 );
        }
        case 22 /* ExtensionApp.getCrashInfo */: {
            const [ a0, a1, a2 ] = args;
            return handler.getCrashInfo( a0, a1, a2 );
        }
        case 23 /* ExtensionApp.getGdtInventory */: {
            const [ a0, a1, a2 ] = args;
            return handler.getGdtInventory( a0, a1, a2 );
        }
        case 24 /* ExtensionApp.getOverworldItems */: {
            const [ a0, a1, a2 ] = args;
            return handler.getOverworldItems( a0, a1, a2 );
        }
        case 25 /* ExtensionApp.getPouchList */: {
            const [ a0, a1, a2 ] = args;
            return handler.getPouchList( a0, a1, a2 );
        }
        case 26 /* ExtensionApp.getScript */: {
            return handler.getScript();
        }
        case 27 /* ExtensionApp.getStepBytePositions */: {
            const [ a0 ] = args;
            return handler.getStepBytePositions( a0 );
        }
        case 28 /* ExtensionApp.getStepCharPositions */: {
            const [ a0 ] = args;
            return handler.getStepCharPositions( a0 );
        }
        case 29 /* ExtensionApp.provideParserDiagnostics */: {
            const [ a0 ] = args;
            return handler.provideParserDiagnostics( a0 );
        }
        case 30 /* ExtensionApp.providePartialRuntimeDiagnostics */: {
            const [ a0, a1, a2 ] = args;
            return handler.providePartialRuntimeDiagnostics( a0, a1, a2 );
        }
        case 31 /* ExtensionApp.provideRuntimeDiagnostics */: {
            const [ a0, a1 ] = args;
            return handler.provideRuntimeDiagnostics( a0, a1 );
        }
        case 32 /* ExtensionApp.provideSemanticTokens */: {
            const [ a0, a1, a2 ] = args;
            return handler.provideSemanticTokens( a0, a1, a2 );
        }
        case 33 /* ExtensionApp.requestNewTaskIds */: {
            const [ a0, a1 ] = args;
            return handler.requestNewTaskIds( a0, a1 );
        }
        case 34 /* ExtensionApp.resolveItem */: {
            const [ a0, a1, a2 ] = args;
            return handler.resolveItem( a0, a1, a2 );
        }
        case 35 /* ExtensionApp.setScript */: {
            const [ a0, a1 ] = args;
            return handler.setScript( a0, a1 );
        }
    } return Promise.resolve({ err: { code: "UnknownFunction" } }); }) as WxBusRecvHandler;
};