/*
 * This file is generated by the workex CLI Tool
 *
 * Please visit https://workex.pistonite.dev for more information
 */

import type { ExtensionApp } from "../extension_app.ts";

import type { Result } from "@pistonite/pure/result";
import type { WxPromise, WxBusRecvHandler, WxProtocolBoundSender } from "@pistonite/workex";
import type { Diagnostic, ItemSearchResult } from "../types.ts";
import type { InvView_Gdt, InvView_Overworld, InvView_PouchList, MaybeAborted, RuntimeViewError } from "../native";
import type { ItemDragData } from "../item_dnd.ts";

/*
 * These generated implementations are used internally by other generated code.
 * They should not be used directly!
 */

/**
 * API implemented by the application and called by the extension.
 */
export class _wxSenderImpl implements ExtensionApp {
    private sender: WxProtocolBoundSender

    constructor(sender: WxProtocolBoundSender) {
        this.sender = sender
    }

    /**
     * Cancel previous requests made to the runtime
     */
    public cancelRuntimeTasks( taskId: string[] ): WxPromise<void> {
        return this.sender.sendVoid(22 /* ExtensionApp.cancelRuntimeTasks */, [ taskId ]);
    }

    /**
     * Get the rendered crash report at the character position `charPos` in the script
     * 
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    public getCrashInfo( taskId: string, script: string | undefined, charPos: number | undefined ): WxPromise<MaybeAborted<string>> {
        return this.sender.send<MaybeAborted<string>>(23 /* ExtensionApp.getCrashInfo */, [ taskId, script, charPos ]);
    }

    /**
     * Get the Game Data inventory state at the character position `charPos` in the script
     * 
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    public getGdtInventory( taskId: string, script: string | undefined, charPos: number | undefined ): WxPromise<MaybeAborted<Result<InvView_Gdt, RuntimeViewError>>> {
        return this.sender.send<MaybeAborted<Result<InvView_Gdt, RuntimeViewError>>>(24 /* ExtensionApp.getGdtInventory */, [ taskId, script, charPos ]);
    }

    /**
     * Get the overworld state at the character position `charPos` in the script
     * 
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    public getOverworldItems( taskId: string, script: string | undefined, charPos: number | undefined ): WxPromise<MaybeAborted<Result<InvView_Overworld, RuntimeViewError>>> {
        return this.sender.send<MaybeAborted<Result<InvView_Overworld, RuntimeViewError>>>(25 /* ExtensionApp.getOverworldItems */, [ taskId, script, charPos ]);
    }

    /**
     * Get the pouch (visible inventory) state.
     * 
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    public getPouchList( taskId: string, script: string | undefined, charPos: number | undefined ): WxPromise<MaybeAborted<Result<InvView_PouchList, RuntimeViewError>>> {
        return this.sender.send<MaybeAborted<Result<InvView_PouchList, RuntimeViewError>>>(26 /* ExtensionApp.getPouchList */, [ taskId, script, charPos ]);
    }

    /**
     * Get the GDT inventory of a named or manual save at the character position `charPos` in the script.
     * Use `undefined` as the name for manual save.
     * 
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    public getSaveInventory( taskId: string, script: string | undefined, charPos: number | undefined, name: string | undefined ): WxPromise<MaybeAborted<Result<InvView_Gdt, RuntimeViewError>>> {
        return this.sender.send<MaybeAborted<Result<InvView_Gdt, RuntimeViewError>>>(27 /* ExtensionApp.getSaveInventory */, [ taskId, script, charPos, name ]);
    }

    /**
     * Get the list of save names at the character position `charPos` in the script.
     * Manual save is not included in the list.
     * 
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    public getSaveNames( taskId: string, script: string | undefined, charPos: number | undefined ): WxPromise<MaybeAborted<string[]>> {
        return this.sender.send<MaybeAborted<string[]>>(28 /* ExtensionApp.getSaveNames */, [ taskId, script, charPos ]);
    }

    /**
     * Get the current simulator script.
     */
    public getScript( ): WxPromise<string> {
        return this.sender.send<string>(29 /* ExtensionApp.getScript */, [ ]);
    }

    /**
     * Get the starting byte positions for each step in the script
     * 
     * Note that the positions are in bytes. Use getStepCharPositions
     * if you need the character positions.
     */
    public getStepBytePositions( script: string ): WxPromise<Uint32Array> {
        return this.sender.send<Uint32Array>(30 /* ExtensionApp.getStepBytePositions */, [ script ]);
    }

    public getStepCharPositions( script: string ): WxPromise<Uint32Array> {
        return this.sender.send<Uint32Array>(31 /* ExtensionApp.getStepCharPositions */, [ script ]);
    }

    /**
     * Get the step index from character position
     * 
     * Pass in `undefined` for `script` and/or `charPos` to use the current state of the application.
     * However, if `script` is not `undefined` and `charPos` is `undefined`,
     * `charPos` defaults to 0
     */
    public getStepFromCharPos( script: string | undefined, charPos: number | undefined ): WxPromise<number> {
        return this.sender.send<number>(32 /* ExtensionApp.getStepFromCharPos */, [ script, charPos ]);
    }

    /**
     * Notify the application that user has started or stopped dragging an item from a different
     * window. Pass in undefined for stop dragging.
     */
    public handleItemDrag( data: ItemDragData | undefined ): WxPromise<void> {
        return this.sender.sendVoid(33 /* ExtensionApp.handleItemDrag */, [ data ]);
    }

    /**
     * Invoke the parser for the script and get the diagnostics.
     */
    public provideParserDiagnostics( script: string ): WxPromise<Diagnostic[]> {
        return this.sender.send<Diagnostic[]>(34 /* ExtensionApp.provideParserDiagnostics */, [ script ]);
    }

    /**
     * Provide only diagnostics from running the script up to and including
     * the step that contains the bytePos.
     */
    public providePartialRuntimeDiagnostics( script: string, taskId: string, bytePos: number ): WxPromise<MaybeAborted<Diagnostic[]>> {
        return this.sender.send<MaybeAborted<Diagnostic[]>>(35 /* ExtensionApp.providePartialRuntimeDiagnostics */, [ script, taskId, bytePos ]);
    }

    /**
     * Get the diagnostics from running the script.
     */
    public provideRuntimeDiagnostics( script: string, taskId: string ): WxPromise<MaybeAborted<Diagnostic[]>> {
        return this.sender.send<MaybeAborted<Diagnostic[]>>(36 /* ExtensionApp.provideRuntimeDiagnostics */, [ script, taskId ]);
    }

    /**
     * Get the semantic tokens for the script in the range.
     * 
     * The output is triples of [start, length, tokenType].
     * 
     * The offsets in both inputs and outputs should be character offsets, not byte offsets.
     * (Note this is different from Runtime.getSemanticTokens)
     */
    public provideSemanticTokens( script: string, start: number, end: number ): WxPromise<Uint32Array> {
        return this.sender.send<Uint32Array>(37 /* ExtensionApp.provideSemanticTokens */, [ script, start, end ]);
    }

    /**
     * Generate new task IDs based on the unique Id.
     * 
     * The previous batch generated by the same unique ID will also
     * be returned, which can be used to cancel previous tasks.
     * 
     * In case of scheduling issues, make sure the new task starts running
     * before canceling the previous one
     */
    public requestNewTaskIds( uniqueId: string, count: number ): WxPromise<string[]> {
        return this.sender.send<string[]>(38 /* ExtensionApp.requestNewTaskIds */, [ uniqueId, count ]);
    }

    /**
     * Resolve an item from a query
     * 
     * If localized is true, treat the query as a localized item search query (i.e. "[tag:]words"),
     * otherwise, treat it as an identifier search query.)
     * 
     * A localized error maybe returned if the query is invalid. However,
     * even when there is no error, the search result could be empty.
     */
    public resolveItem( query: string, localized: boolean, limit: number ): WxPromise<Result<ItemSearchResult[], string>> {
        return this.sender.send<Result<ItemSearchResult[], string>>(39 /* ExtensionApp.resolveItem */, [ query, localized, limit ]);
    }

    /**
     * Set the simulator script.
     * 
     * This will trigger a rerun of the simulation using the new script
     * 
     * Position is the current cursor position in the script as
     * a character offset (not byte offset) and is 0-based.
     */
    public setScript( script: string, position: number ): WxPromise<void> {
        return this.sender.sendVoid(40 /* ExtensionApp.setScript */, [ script, position ]);
    }
}

/**
 * API implemented by the application and called by the extension.
 */
export const _wxRecverImpl = (handler: ExtensionApp): WxBusRecvHandler => {
    return ((fId, args: any[]) => { switch (fId) {
        case 22 /* ExtensionApp.cancelRuntimeTasks */: {
            const [ a0 ] = args;
            return handler.cancelRuntimeTasks( a0 );
        }
        case 23 /* ExtensionApp.getCrashInfo */: {
            const [ a0, a1, a2 ] = args;
            return handler.getCrashInfo( a0, a1, a2 );
        }
        case 24 /* ExtensionApp.getGdtInventory */: {
            const [ a0, a1, a2 ] = args;
            return handler.getGdtInventory( a0, a1, a2 );
        }
        case 25 /* ExtensionApp.getOverworldItems */: {
            const [ a0, a1, a2 ] = args;
            return handler.getOverworldItems( a0, a1, a2 );
        }
        case 26 /* ExtensionApp.getPouchList */: {
            const [ a0, a1, a2 ] = args;
            return handler.getPouchList( a0, a1, a2 );
        }
        case 27 /* ExtensionApp.getSaveInventory */: {
            const [ a0, a1, a2, a3 ] = args;
            return handler.getSaveInventory( a0, a1, a2, a3 );
        }
        case 28 /* ExtensionApp.getSaveNames */: {
            const [ a0, a1, a2 ] = args;
            return handler.getSaveNames( a0, a1, a2 );
        }
        case 29 /* ExtensionApp.getScript */: {
            return handler.getScript();
        }
        case 30 /* ExtensionApp.getStepBytePositions */: {
            const [ a0 ] = args;
            return handler.getStepBytePositions( a0 );
        }
        case 31 /* ExtensionApp.getStepCharPositions */: {
            const [ a0 ] = args;
            return handler.getStepCharPositions( a0 );
        }
        case 32 /* ExtensionApp.getStepFromCharPos */: {
            const [ a0, a1 ] = args;
            return handler.getStepFromCharPos( a0, a1 );
        }
        case 33 /* ExtensionApp.handleItemDrag */: {
            const [ a0 ] = args;
            return handler.handleItemDrag( a0 );
        }
        case 34 /* ExtensionApp.provideParserDiagnostics */: {
            const [ a0 ] = args;
            return handler.provideParserDiagnostics( a0 );
        }
        case 35 /* ExtensionApp.providePartialRuntimeDiagnostics */: {
            const [ a0, a1, a2 ] = args;
            return handler.providePartialRuntimeDiagnostics( a0, a1, a2 );
        }
        case 36 /* ExtensionApp.provideRuntimeDiagnostics */: {
            const [ a0, a1 ] = args;
            return handler.provideRuntimeDiagnostics( a0, a1 );
        }
        case 37 /* ExtensionApp.provideSemanticTokens */: {
            const [ a0, a1, a2 ] = args;
            return handler.provideSemanticTokens( a0, a1, a2 );
        }
        case 38 /* ExtensionApp.requestNewTaskIds */: {
            const [ a0, a1 ] = args;
            return handler.requestNewTaskIds( a0, a1 );
        }
        case 39 /* ExtensionApp.resolveItem */: {
            const [ a0, a1, a2 ] = args;
            return handler.resolveItem( a0, a1, a2 );
        }
        case 40 /* ExtensionApp.setScript */: {
            const [ a0, a1 ] = args;
            return handler.setScript( a0, a1 );
        }
    } return Promise.resolve({ err: { code: "UnknownFunction" } }); }) as WxBusRecvHandler;
};