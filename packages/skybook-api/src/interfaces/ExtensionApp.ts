/*
 * This file is generated by the workex CLI Tool
 *
 * Please visit https://workex.pistonite.dev for more information
 */

import type { ExtensionApp } from "../ExtensionApp.ts";

import type { Result } from "@pistonite/pure/result";
import type { WxPromise, WxBusRecvHandler, WxProtocolBoundSender } from "@pistonite/workex";
import type { Diagnostic, ItemSearchResult } from "../types.ts";
import type { InvView_Gdt, InvView_Overworld, InvView_PouchList, MaybeAborted, RuntimeViewError } from "../native";

/*
 * These generated implementations are used internally by other generated code.
 * They should not be used directly!
 */

/**
 * API implemented by the application and called by the extension.
 */
export class _wxSenderImpl implements ExtensionApp {
    private sender: WxProtocolBoundSender

    constructor(sender: WxProtocolBoundSender) {
        this.sender = sender
    }

    /**
     * Cancel a previous request made to the runtime
     */
    public cancelRuntimeTask( taskId: string ): WxPromise<void> {
        return this.sender.sendVoid(20 /* ExtensionApp.cancelRuntimeTask */, [ taskId ]);
    }

    /**
     * Get the rendered crash report at the byte offset `pos` in the script
     * 
     * Pass in `undefined` to use the current state of the application.
     * However, if `script` is not `undefined` and `pos` is `undefined`,
     * pos defaults to 0
     */
    public getCrashInfo( taskId: string, script: string | undefined, charPos: number | undefined ): WxPromise<MaybeAborted<string>> {
        return this.sender.send<MaybeAborted<string>>(21 /* ExtensionApp.getCrashInfo */, [ taskId, script, charPos ]);
    }

    /**
     * Get the Game Data inventory state at the byte offset `pos` in the script
     * 
     * Pass in `undefined` to use the current state of the application.
     * However, if `script` is not `undefined` and `pos` is `undefined`,
     * pos defaults to 0
     */
    public getGdtInventory( taskId: string, script: string | undefined, charPos: number | undefined ): WxPromise<MaybeAborted<Result<InvView_Gdt, RuntimeViewError>>> {
        return this.sender.send<MaybeAborted<Result<InvView_Gdt, RuntimeViewError>>>(22 /* ExtensionApp.getGdtInventory */, [ taskId, script, charPos ]);
    }

    /**
     * Get the overworld state at the byte offset `pos` in the script
     * 
     * Pass in `undefined` to use the current state of the application.
     * However, if `script` is not `undefined` and `pos` is `undefined`,
     * pos defaults to 0
     */
    public getOverworldItems( taskId: string, script: string | undefined, charPos: number | undefined ): WxPromise<MaybeAborted<Result<InvView_Overworld, RuntimeViewError>>> {
        return this.sender.send<MaybeAborted<Result<InvView_Overworld, RuntimeViewError>>>(23 /* ExtensionApp.getOverworldItems */, [ taskId, script, charPos ]);
    }

    /**
     * Get the pouch (visible inventory) state.
     * 
     * Pass in `undefined` to use the current state of the application.
     * However, if `script` is not `undefined` and `pos` is `undefined`,
     * pos defaults to 0
     */
    public getPouchList( taskId: string, script: string | undefined, charPos: number | undefined ): WxPromise<MaybeAborted<Result<InvView_PouchList, RuntimeViewError>>> {
        return this.sender.send<MaybeAborted<Result<InvView_PouchList, RuntimeViewError>>>(24 /* ExtensionApp.getPouchList */, [ taskId, script, charPos ]);
    }

    /**
     * Get the current simulator script.
     */
    public getScript( ): WxPromise<string> {
        return this.sender.send<string>(25 /* ExtensionApp.getScript */, [ ]);
    }

    /**
     * Invoke the parser for the script and get the diagnostics.
     */
    public provideParserDiagnostics( script: string ): WxPromise<Diagnostic[]> {
        return this.sender.send<Diagnostic[]>(26 /* ExtensionApp.provideParserDiagnostics */, [ script ]);
    }

    /**
     * Get the diagnostics from running the script.
     */
    public provideRuntimeDiagnostics( script: string, taskId: string ): WxPromise<MaybeAborted<Diagnostic[]>> {
        return this.sender.send<MaybeAborted<Diagnostic[]>>(27 /* ExtensionApp.provideRuntimeDiagnostics */, [ script, taskId ]);
    }

    /**
     * Get the semantic tokens for the script in the range.
     * 
     * The output is triples of [start, length, tokenType].
     * 
     * The offsets in both inputs and outputs should be character offsets, not byte offsets.
     * (Note this is different from Runtime.getSemanticTokens)
     */
    public provideSemanticTokens( script: string, start: number, end: number ): WxPromise<Uint32Array> {
        return this.sender.send<Uint32Array>(28 /* ExtensionApp.provideSemanticTokens */, [ script, start, end ]);
    }

    /**
     * Generate a new task ID based on the unique Id. The previous
     * task id returned by this function with the same unique ID will be
     * aborted automatically
     */
    public requestNewTaskId( uniqueId: string ): WxPromise<string> {
        return this.sender.send<string>(29 /* ExtensionApp.requestNewTaskId */, [ uniqueId ]);
    }

    /**
     * Resolve an item from a query
     * 
     * If localized is true, treat the query as a localized item search query (i.e. "[tag:]words"),
     * otherwise, treat it as an identifier search query.)
     * 
     * A localized error maybe returned if the query is invalid. However,
     * even when there is no error, the search result could be empty.
     */
    public resolveItem( query: string, localized: boolean, limit: number ): WxPromise<Result<ItemSearchResult[], string>> {
        return this.sender.send<Result<ItemSearchResult[], string>>(30 /* ExtensionApp.resolveItem */, [ query, localized, limit ]);
    }

    /**
     * Set the simulator script.
     * 
     * This will trigger a rerun of the simulation using the new script
     * 
     * Position is the current cursor position in the script as
     * a character offset (not byte offset) and is 0-based.
     */
    public setScript( script: string, position: number ): WxPromise<void> {
        return this.sender.sendVoid(31 /* ExtensionApp.setScript */, [ script, position ]);
    }
}

/**
 * API implemented by the application and called by the extension.
 */
export const _wxRecverImpl = (handler: ExtensionApp): WxBusRecvHandler => {
    return ((fId, args: any[]) => { switch (fId) {
        case 20 /* ExtensionApp.cancelRuntimeTask */: {
            const [ a0 ] = args;
            return handler.cancelRuntimeTask( a0 );
        }
        case 21 /* ExtensionApp.getCrashInfo */: {
            const [ a0, a1, a2 ] = args;
            return handler.getCrashInfo( a0, a1, a2 );
        }
        case 22 /* ExtensionApp.getGdtInventory */: {
            const [ a0, a1, a2 ] = args;
            return handler.getGdtInventory( a0, a1, a2 );
        }
        case 23 /* ExtensionApp.getOverworldItems */: {
            const [ a0, a1, a2 ] = args;
            return handler.getOverworldItems( a0, a1, a2 );
        }
        case 24 /* ExtensionApp.getPouchList */: {
            const [ a0, a1, a2 ] = args;
            return handler.getPouchList( a0, a1, a2 );
        }
        case 25 /* ExtensionApp.getScript */: {
            return handler.getScript();
        }
        case 26 /* ExtensionApp.provideParserDiagnostics */: {
            const [ a0 ] = args;
            return handler.provideParserDiagnostics( a0 );
        }
        case 27 /* ExtensionApp.provideRuntimeDiagnostics */: {
            const [ a0, a1 ] = args;
            return handler.provideRuntimeDiagnostics( a0, a1 );
        }
        case 28 /* ExtensionApp.provideSemanticTokens */: {
            const [ a0, a1, a2 ] = args;
            return handler.provideSemanticTokens( a0, a1, a2 );
        }
        case 29 /* ExtensionApp.requestNewTaskId */: {
            const [ a0 ] = args;
            return handler.requestNewTaskId( a0 );
        }
        case 30 /* ExtensionApp.resolveItem */: {
            const [ a0, a1, a2 ] = args;
            return handler.resolveItem( a0, a1, a2 );
        }
        case 31 /* ExtensionApp.setScript */: {
            const [ a0, a1 ] = args;
            return handler.setScript( a0, a1 );
        }
    } return Promise.resolve({ err: { code: "UnknownFunction" } }); }) as WxBusRecvHandler;
};