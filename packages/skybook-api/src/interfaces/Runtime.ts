/*
 * This file is generated by the workex CLI Tool
 *
 * Please visit https://workex.pistonite.dev for more information
 */

import type { Runtime } from "../runtime_api.ts";

import type { WxPromise, WxBusRecvHandler, WxProtocolBoundSender } from "@pistonite/workex";
import type { Result } from "@pistonite/pure/result";
import type { ErrorReport, InvView_Gdt, InvView_Overworld, InvView_PouchList, MaybeAborted, ParserError, RuntimeError, RuntimeViewError } from "../native";
import type { ItemSearchResult, RuntimeWorkerInitArgs, RuntimeWorkerInitOutput, RuntimeWorkerInitError } from "../types.ts";

/*
 * These generated implementations are used internally by other generated code.
 * They should not be used directly!
 */

/**
 * API provided by the simulator runtime, called by the application.
 */
export class _wxSenderImpl implements Runtime {
    private sender: WxProtocolBoundSender

    constructor(sender: WxProtocolBoundSender) {
        this.sender = sender
    }

    /**
     * Abort a task by task id passed into one of the runtime functions that execute the script
     */
    public abortTask( taskId: string ): WxPromise<void> {
        return this.sender.sendVoid(35 /* Runtime.abortTask */, [ taskId ]);
    }

    /**
     * Trigger a script execution
     * 
     * This isn't normally needed, if you just need to execute the script AND get output
     * at some step. This is used by the app to make sure the script keeps running
     * in the background if it didn't change.
     */
    public executeScript( script: string, taskId: string ): WxPromise<void> {
        return this.sender.sendVoid(36 /* Runtime.executeScript */, [ script, taskId ]);
    }

    /**
     * Execute the script if not up-to-date. If at the byte offset `pos` in the script,
     * the game crashed, return the rendered crash report as a string. Otherwise return
     * empty string.
     * 
     * The taskId should be a UUID, and can be passed into abortTask() to abort this run
     */
    public getCrashInfo( script: string, taskId: string, pos: number ): WxPromise<MaybeAborted<string>> {
        return this.sender.send<MaybeAborted<string>>(37 /* Runtime.getCrashInfo */, [ script, taskId, pos ]);
    }

    /**
     * Execute the script if not up-to-date, and return the GDT inventory view
     * at the byte offset `pos` in the script.
     * 
     * The taskId should be a UUID, and can be passed into abortTask() to abort this run
     */
    public getGdtInventory( script: string, taskId: string, pos: number ): WxPromise<MaybeAborted<Result<InvView_Gdt, RuntimeViewError>>> {
        return this.sender.send<MaybeAborted<Result<InvView_Gdt, RuntimeViewError>>>(38 /* Runtime.getGdtInventory */, [ script, taskId, pos ]);
    }

    /**
     * Execute the script if not up-to-date, and return the overworld item view
     * at the byte offset `pos` in the script.
     * 
     * The taskId should be a UUID, and can be passed into abortTask() to abort this run
     */
    public getOverworldItems( script: string, taskId: string, pos: number ): WxPromise<MaybeAborted<Result<InvView_Overworld, RuntimeViewError>>> {
        return this.sender.send<MaybeAborted<Result<InvView_Overworld, RuntimeViewError>>>(39 /* Runtime.getOverworldItems */, [ script, taskId, pos ]);
    }

    /**
     * Parse the script and get diagnostics from the parser.
     * 
     * Note that the span in the errors are byte offsets, not character offsets.
     */
    public getParserDiagnostics( script: string ): WxPromise<ErrorReport<ParserError>[]> {
        return this.sender.send<ErrorReport<ParserError>[]>(40 /* Runtime.getParserDiagnostics */, [ script ]);
    }

    /**
     * Execute the script if not up-to-date, and return the pouch inventory list view
     * at the byte offset `pos` in the script.
     * 
     * The taskId should be a UUID, and can be passed into abortTask() to abort this run
     */
    public getPouchList( script: string, taskId: string, pos: number ): WxPromise<MaybeAborted<Result<InvView_PouchList, RuntimeViewError>>> {
        return this.sender.send<MaybeAborted<Result<InvView_PouchList, RuntimeViewError>>>(41 /* Runtime.getPouchList */, [ script, taskId, pos ]);
    }

    /**
     * Run the script and get diagnostics from the runtime, up to and including
     * the step containing the bytePos
     * 
     * Note that the span in the errors are byte offsets, not character offsets.
     * 
     * The taskId should be a UUID, and can be passed into abortTask() to abort this run
     */
    public getRuntimeDiagnostics( script: string, taskId: string, bytePos: number ): WxPromise<MaybeAborted<ErrorReport<RuntimeError>[]>> {
        return this.sender.send<MaybeAborted<ErrorReport<RuntimeError>[]>>(42 /* Runtime.getRuntimeDiagnostics */, [ script, taskId, bytePos ]);
    }

    /**
     * Parse the script and get semantic tokens in the range from the parser.
     * 
     * The output is triples of [start, length, tokenType]
     * 
     * The offsets in both inputs and outputs should be byte offsets, not character offsets.
     */
    public getSemanticTokens( script: string, start: number, end: number ): WxPromise<Uint32Array> {
        return this.sender.send<Uint32Array>(43 /* Runtime.getSemanticTokens */, [ script, start, end ]);
    }

    /**
     * Get the starting byte positions for each step
     */
    public getStepBytePositions( script: string ): WxPromise<Uint32Array> {
        return this.sender.send<Uint32Array>(44 /* Runtime.getStepBytePositions */, [ script ]);
    }

    /**
     * Get index of the step from byte position in the script
     */
    public getStepFromPos( script: string, pos: number ): WxPromise<number> {
        return this.sender.send<number>(45 /* Runtime.getStepFromPos */, [ script, pos ]);
    }

    /**
     * Initialize the runtime with the given arguments.
     */
    public initialize( args: RuntimeWorkerInitArgs ): WxPromise<Result<RuntimeWorkerInitOutput, RuntimeWorkerInitError>> {
        return this.sender.send<Result<RuntimeWorkerInitOutput, RuntimeWorkerInitError>>(46 /* Runtime.initialize */, [ args ]);
    }

    /**
     * Resolve an item identifier search query to a list of items, ordered by score (best first).
     * Returns an empty list if no items are found.
     */
    public resolveItemIdent( query: string ): WxPromise<ItemSearchResult[]> {
        return this.sender.send<ItemSearchResult[]>(47 /* Runtime.resolveItemIdent */, [ query ]);
    }
}

/**
 * API provided by the simulator runtime, called by the application.
 */
export const _wxRecverImpl = (handler: Runtime): WxBusRecvHandler => {
    return ((fId, args: any[]) => { switch (fId) {
        case 35 /* Runtime.abortTask */: {
            const [ a0 ] = args;
            return handler.abortTask( a0 );
        }
        case 36 /* Runtime.executeScript */: {
            const [ a0, a1 ] = args;
            return handler.executeScript( a0, a1 );
        }
        case 37 /* Runtime.getCrashInfo */: {
            const [ a0, a1, a2 ] = args;
            return handler.getCrashInfo( a0, a1, a2 );
        }
        case 38 /* Runtime.getGdtInventory */: {
            const [ a0, a1, a2 ] = args;
            return handler.getGdtInventory( a0, a1, a2 );
        }
        case 39 /* Runtime.getOverworldItems */: {
            const [ a0, a1, a2 ] = args;
            return handler.getOverworldItems( a0, a1, a2 );
        }
        case 40 /* Runtime.getParserDiagnostics */: {
            const [ a0 ] = args;
            return handler.getParserDiagnostics( a0 );
        }
        case 41 /* Runtime.getPouchList */: {
            const [ a0, a1, a2 ] = args;
            return handler.getPouchList( a0, a1, a2 );
        }
        case 42 /* Runtime.getRuntimeDiagnostics */: {
            const [ a0, a1, a2 ] = args;
            return handler.getRuntimeDiagnostics( a0, a1, a2 );
        }
        case 43 /* Runtime.getSemanticTokens */: {
            const [ a0, a1, a2 ] = args;
            return handler.getSemanticTokens( a0, a1, a2 );
        }
        case 44 /* Runtime.getStepBytePositions */: {
            const [ a0 ] = args;
            return handler.getStepBytePositions( a0 );
        }
        case 45 /* Runtime.getStepFromPos */: {
            const [ a0, a1 ] = args;
            return handler.getStepFromPos( a0, a1 );
        }
        case 46 /* Runtime.initialize */: {
            const [ a0 ] = args;
            return handler.initialize( a0 );
        }
        case 47 /* Runtime.resolveItemIdent */: {
            const [ a0 ] = args;
            return handler.resolveItemIdent( a0 );
        }
    } return Promise.resolve({ err: { code: "UnknownFunction" } }); }) as WxBusRecvHandler;
};