// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.
import type { InvView_CommonItem } from "./InvView_CommonItem";
import type { InvView_ItemData } from "./InvView_ItemData";
import type { Pointer } from "./Pointer";

/**
 * Info for an item in the PMDM. This struct can represent both
 * valid item and invalid items (resulting from ISU corruption)
 */
export type InvView_PouchItem = {
    /**
     * Common item info
     */
    common: InvView_CommonItem;
    /**
     * PouchItem::mType
     *
     * Note this is raw memory value and may not be a valid enum value
     */
    itemType: number;
    /**
     * PouchItem::mItemUse
     *
     * Note this is raw memory value and may not be a valid enum value
     */
    itemUse: number;
    /**
     * PouchItem::mInInventory
     */
    isInInventory: boolean;
    /**
     * For animated items, if this slot would have no icon in the inventory
     */
    isNoIcon: boolean;
    /**
     * Extra data (CookData or WeaponData) for the item
     */
    data: InvView_ItemData;
    /**
     * Ingredients of the item
     */
    ingredients: [string, string, string, string, string];
    /**
     * Number of items held if the item is being held by the player
     */
    holdingCount: number;
    /**
     * Enable the prompt entangled state for this slot
     */
    promptEntangled: boolean;
    /**
     * Physical address (pointer) of the node.
     *
     * This is address of the list node, not the PouchItem.
     * The PouchItem pointer can be obtained by subtracting 8 from this value
     */
    nodeAddr: Pointer;
    /**
     * Is this a valid node, in the item array
     */
    nodeValid: boolean;
    /**
     * Position of the node
     *
     * If the node is valid, this is the index of the node in the item array.
     * Otherwise, this is the byte offset (ptrdiff) of the node from beginning of PMDM
     */
    nodePos: bigint;
    /**
     * Pointer to the previous node
     */
    nodePrev: Pointer;
    /**
     * Pointer to the next node
     */
    nodeNext: Pointer;
    /**
     * Position of the node in the allocated list.
     * i.e. how many times `.next` needs to be followed from the head of the list
     * to reach this node.
     *
     * If this node is not reachable from the head of the list by following `.next` , this is -1
     */
    allocatedIdx: number;
    /**
     * Position of the node in the unallocated list.
     * i.e. how many times `.next` needs to be followed from the head of the list
     * to reach this node.
     *
     * If this node is not reachable from the head of the list by following `.next` , this is -1
     */
    unallocatedIdx: number;
    /**
     * If the tab data is valid, the index of the tab this item is in.
     * Note that this may not be consecutive for consecutive items,
     * as there could be empty tabs
     */
    tabIdx: number;
    /**
     * If the tab data is valid, the slot of the item in the tab.
     *
     * This is usually 0-20. For arrows, this is the actual position to be displayed
     * (i.e. first arrow would be 5 if there are 5 bow slots, including empty)
     */
    tabSlot: number;
    /**
     * If the item is accessible (visible) in the inventory
     *
     * Not accessible cases include:
     * - mCount is 0, whole inventory is not accessible
     * - Weapon/Bow/Shield is outside of the slot range
     */
    accessible: boolean;
    /**
     * If the item is accessible via the dpad menu
     */
    dpadAccessible: boolean;
};
