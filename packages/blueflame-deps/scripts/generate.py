import os

import yaml
SELF_DIR = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
RESEARCH_SCRIPTS_DIR = os.path.join(os.path.dirname(SELF_DIR), "research-scripts")
if not os.path.exists(RESEARCH_SCRIPTS_DIR):
    raise Exception(f"botw-research-scripts not found: {RESEARCH_SCRIPTS_DIR}")
import sys
sys.path.append(os.path.join(RESEARCH_SCRIPTS_DIR, "src"))
import spp # type: ignore

HEADER = """
//! This file is auto-generated by scripts/generate.py
//! DO NOT EDIT MANUALLY
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(clippy::excessive_precision)]
use crate::gdt;
"""

def main():
    lines = [HEADER]
    max_lengths = {
        "FALSE_BOOL": 0,
        "ZERO_I32": 0,
        "NEGONE_I32": 0,
        "EMPTY_STR": 0,
        "VEC2F_NEGONE_ZERO": 0,
    }
    gen_bool_flag_pack()
    gen_s32_flag_pack()
    generate_flag_function("ArrayBool.yaml", lines, max_lengths)
    generate_flag_function("ArrayS32.yaml", lines, max_lengths)
    generate_flag_function("ArrayF32.yaml", lines, max_lengths)
    generate_flag_function("ArrayString64.yaml", lines, max_lengths)
    generate_flag_function("ArrayString256.yaml", lines, max_lengths)
    generate_flag_function("ArrayVector2f.yaml", lines, max_lengths)
    generate_flag_function("ArrayVector3f.yaml", lines, max_lengths)
    # generate_flag_function("Bool.yaml", lines, max_lengths)
    generate_flag_function("F32.yaml", lines, max_lengths)
    # generate_flag_function("S32.yaml", lines, max_lengths)
    generate_flag_function("String32.yaml", lines, max_lengths)
    generate_flag_function("String64.yaml", lines, max_lengths)
    generate_flag_function("String256.yaml", lines, max_lengths)
    generate_flag_function("Vector2f.yaml", lines, max_lengths)
    generate_flag_function("Vector3f.yaml", lines, max_lengths)
    generate_flag_function("Vector4f.yaml", lines, max_lengths)

    lines += [
        "#[rustfmt::skip]",
        "static FALSE_BOOL: &[bool] = &[" + ", ".join(["false"] * max_lengths["FALSE_BOOL"]) + "];",
        "#[rustfmt::skip]",
        "static ZERO_I32: &[i32] = &[" + ", ".join(["0"] * max_lengths["ZERO_I32"]) + "];",
        "#[rustfmt::skip]",
        "static NEGONE_I32: &[i32] = &[" + ", ".join(["-1"] * max_lengths["NEGONE_I32"]) + "];",
        "#[rustfmt::skip]",
        "static EMPTY_STR: &[&str] = &[" + ", ".join(["\"\""] * max_lengths["EMPTY_STR"]) + "];",
        "#[rustfmt::skip]",
        "static VEC2F_NEGONE_ZERO: &[(f32, f32)] = &[" + ", ".join(["(-1f32, 0f32)"] * max_lengths["VEC2F_NEGONE_ZERO"]) + "];",
    ]

    with open(os.path.join(SELF_DIR, "src", "generated", "gdt.rs"), "w", encoding="utf-8", newline="\n") as f:
        f.write("\n".join(lines))
        f.write("\n")

def generate_flag_function(file: str, lines: list[str], max_lengths):
    is_array = file.startswith("Array")
    flag_type = "gdt::StringFlagType"
    flag_name = file.replace(".", "_")
    if file.endswith("Bool.yaml"):
        flag_type = "bool"
    elif file.endswith("F32.yaml"):
        flag_type = "f32"
    elif file.endswith("S32.yaml"):
        flag_type = "i32"
    elif file.endswith("Vector2f.yaml"):
        flag_type = "(f32, f32)"
    elif file.endswith("Vector3f.yaml"):
        flag_type = "(f32, f32, f32)"
    elif file.endswith("Vector4f.yaml"):
        flag_type = "(f32, f32, f32, f32)"
    flag_static_type = flag_type
    if flag_static_type == "gdt::StringFlagType":
        flag_static_type = "&str"
    if is_array:
        flag_type = f"gdt::ArrayFlagType<{flag_type}>"

    with open(os.path.join(RESEARCH_SCRIPTS_DIR, "output", "GameData", file), "r", encoding="utf-8") as f:
        entries = yaml.safe_load(f)

    progress = spp.printer(len(entries), f"Generate {file} flag function")
    lines += [
        "#[rustfmt::skip]",
        "#[doc(hidden)]",
        f"pub fn generate_{flag_name}_flags() -> gdt::FlagList<{flag_type}> {{ vec![",
    ]
    static_values = []
    for i, entry in enumerate(entries):
        progress.update(i)
        content = generate_flag_entry(entry, flag_static_type, is_array, max_lengths, static_values)
        lines.append(f"    {content},")
    lines.append("] }")
    lines += static_values
    progress.done()

def generate_flag_entry(entry, typ, is_array, max_lengths, static_values):
    name = entry["name"]
    hash = entry["hash"]
    flags = entry["prop_flags"]
    minmax = (entry["min"], entry["max"]) if ("min" in entry and "max" in entry) else None
    initial = entry["initial"]
    if is_array and "len" not in entry:
        raise ValueError(f"Array entry '{name}' must have a 'len' field.")
    if is_array and len(initial) < entry["len"]:
        for _ in range(entry["len"] - len(initial)):
            initial.append(initial[-1])

    value_tokens = to_token(
        name, 
        initial, 
        typ, 
        is_array, 
        max_lengths,
        static_values
    )

    hash_str = f"0x{(hash & 0xffffffff):08x}u32 as i32"
    
    if minmax is None:
        return f"gdt::Flag::new({hash_str},{value_tokens},{flags})/*{name}*/"
    min_tokens = to_token(name+"_MIN", minmax[0], typ, False, max_lengths, static_values)
    max_tokens = to_token(name+"_MAX", minmax[1], typ, False, max_lengths, static_values)
    return f"gdt::Flag::new_minmax({hash_str},{value_tokens},{flags},{min_tokens},{max_tokens})/*{name}*/"

def gen_bool_flag_pack():
    print("Generating bool flag pack...")
    with open(os.path.join(RESEARCH_SCRIPTS_DIR, "output", "GameData", "Bool.yaml"), "r", encoding="utf-8") as f:
        entries = yaml.safe_load(f)
    bytes = bytearray()
    for entry in entries:
        hash = entry["hash"]
        bytes += hash.to_bytes(4, byteorder='little', signed=False)
        initial = entry["initial"]
        last_byte = 0x80 if initial else 0x00
        last_byte |= entry["prop_flags"]
        bytes.append(last_byte)
    with open(os.path.join(SELF_DIR, "src", "generated", "bool_flag_pack.bin"), "wb") as f:
        f.write(bytes)

def gen_s32_flag_pack():
    print("Generating s32 flag pack...")
    with open(os.path.join(RESEARCH_SCRIPTS_DIR, "output", "GameData", "S32.yaml"), "r", encoding="utf-8") as f:
        entries = yaml.safe_load(f)
    bytes = bytearray()
    for entry in entries:
        hash = entry["hash"]
        bytes += hash.to_bytes(4, byteorder='little', signed=False)
        initial = entry["initial"]
        bytes += initial.to_bytes(4, byteorder='little', signed=True)
        min = entry["min"]
        max = entry["max"]
        bytes += min.to_bytes(4, byteorder='little', signed=True)
        bytes += max.to_bytes(4, byteorder='little', signed=True)
        prop_flags = entry["prop_flags"]
        bytes.append(prop_flags & 0xFF)
    with open(os.path.join(SELF_DIR, "src", "generated", "s32_flag_pack.bin"), "wb") as f:
        f.write(bytes)


def to_token(name, value, typ, is_array, max_lengths, static_values):
    if isinstance(value, str):
        return f'"{value}"'
    elif isinstance(value, bool):
        return "true" if value else "false"
    elif isinstance(value, int):
        return str(value)
    elif isinstance(value, float):
        return str(value) + "f32"
    elif isinstance(value, list):
        if is_array:
            if typ == "bool":
                if are_all(value, False):
                    max_lengths["FALSE_BOOL"] = max(max_lengths["FALSE_BOOL"], len(value))
                    return f"&FALSE_BOOL[..{len(value)}]"
            if typ == "i32":
                if are_all(value, 0):
                    max_lengths["ZERO_I32"] = max(max_lengths["ZERO_I32"], len(value))
                    return f"&ZERO_I32[..{len(value)}]"
                if are_all(value, -1):
                    max_lengths["NEGONE_I32"] = max(max_lengths["NEGONE_I32"], len(value))
                    return f"&NEGONE_I32[..{len(value)}]"
            if typ == "&str":
                if are_all(value, ""):
                    max_lengths["EMPTY_STR"] = max(max_lengths["EMPTY_STR"], len(value))
                    return f"&EMPTY_STR[..{len(value)}]"
            if typ == "(f32, f32)":
                if are_all(value, (-1.0, 0.0)) or are_all(value, [-1.0, 0.0]):
                    max_lengths["VEC2F_NEGONE_ZERO"] = max(max_lengths["VEC2F_NEGONE_ZERO"], len(value))
                    return f"&VEC2F_NEGONE_ZERO[..{len(value)}]"
            static_value = "&[" + ", ".join(to_token(name, v, typ, False, max_lengths, static_values) for v in value) + "]"
            static_values.append(f"static {name}_VALUE: &[{typ}] = {static_value};")
            return f"{name}_VALUE"
        return "(" + ", ".join(to_token(name, v, typ, False, max_lengths, static_values) for v in value) + ")"
    else:
        raise ValueError(f"Unsupported type: {type(value)}")

def are_all(array, value):
    return all(v == value for v in array)

if __name__ == "__main__":
    main()
