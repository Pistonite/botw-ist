use std::collections::BTreeMap;
use std::path::Path;

use cu::pre::*;

fn main() -> cu::Result<()> {
    generate_item_name()
}

fn generate_item_name() -> cu::Result<()> {
    let manifest_dir = manifest_dir();
    let input = Path::new(&manifest_dir)
        .join("data")
        .join("item-search-terms.yaml");
    println!("cargo::rerun-if-changed={}", input.as_utf8()?);
    // using BTreeMap to ensure sorted keys for stable output
    let input = yaml::read::<BTreeMap<String, String>>(cu::fs::reader(input)?)?;

    let mut output_path = Path::new(&manifest_dir)
        .join("src")
        .join("data");
    cu::fs::make_dir(&output_path)?;
    output_path.push("item_name.gen.rs");

    let mut output = r#"// This file is auto-generated by the build script
// DO NOT EDIT MANUALLY

#[rustfmt::skip]
pub static ITEM_NAMES: &[SearchName] = &[
"#
    .to_string();

    let mut ids = Vec::with_capacity(input.len());
    for (item_key, actor_name) in input {
        let (item_name, id_len, is_material) = parse_item_key(&item_key)?;
        ids.push(item_name[..id_len].to_string());
        output.push_str(&format!(
            r#"    SearchName::new("{item_name}", "{actor_name}", {is_material}, {id_len}),"#
        ));
        output.push('\n');
    }

    // verify the ids are already sorted
    // i.e. the ids and item_keys have the same sort order
    // the item search algorithm assumes this
    let mut ids_sorted = ids.clone();
    ids_sorted.sort();
    cu::ensure!(ids == ids_sorted);

    output += "];\n";

    cu::fs::write(output_path, output)?;
    Ok(())
}

fn parse_item_key(key: &str) -> cu::Result<(String, usize, bool)> {
    let (key, tags) = {
        let mut parts = key.splitn(2, '@');
        let key = cu::check!(parts.next(), "cannot find key")?;
        let tags: Vec<_> = parts
            .next()
            .map(|x| x.split(',').collect())
            .unwrap_or_default();
        (key, tags)
    };
    let (word, short) = {
        let mut parts = key.splitn(2, ':');
        let word = cu::check!(parts.next(), "cannot find word")?;
        let short = parts.next().unwrap_or_default();
        (word, short)
    };

    let mut is_material = false;
    for tag in tags {
        if tag == "material" {
            is_material = true;
        }
    }
    Ok((format!("{word}{short}"), word.len(), is_material))
}

fn manifest_dir() -> String {
    std::env::var("LAYERED_CRATE_ORIGINAL_MANIFEST_DIR")
    .unwrap_or(env!("CARGO_MANIFEST_DIR").to_string())
}
