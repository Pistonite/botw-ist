/**
 * This file is generated by workex
 */
import type { RuntimeApi } from "../protocol.ts";

import { type WorkexPromise, WorkexClient, type WorkexClientOptions } from "@pistonite/workex";
import { ParserError } from ".././parserTypes.ts";

/**
 * API provided by the simulator runtime
 * 
 * @workex:send app
 * @workex:recv runtime
 */
export class RuntimeApiClient implements RuntimeApi {
    private client: WorkexClient<"runtime">

    constructor(options: WorkexClientOptions) {
        this.client = new WorkexClient("runtime", options);
    }

    /**
     */
    public getInventory( scriptHash: string, step: number ): WorkexPromise<unknown> {
        return this.client.post<unknown>(16 /* RuntimeApi.getInventory */, [ scriptHash, step ]);
    }

    /**
     */
    public getParserDiagnostics( script: string ): WorkexPromise<ParserError[]> {
        return this.client.post<ParserError[]>(17 /* RuntimeApi.getParserDiagnostics */, [ script ]);
    }

    /**
     */
    public getRuntimeDiagnostics( script: string ): WorkexPromise<{ range: [number, number]; message: string }[]> {
        return this.client.post<{ range: [number, number]; message: string }[]>(18 /* RuntimeApi.getRuntimeDiagnostics */, [ script ]);
    }

    /**
     */
    public getSemanticTokens( script: string, startPos: number, endPos: number ): WorkexPromise<Uint32Array> {
        return this.client.post<Uint32Array>(19 /* RuntimeApi.getSemanticTokens */, [ script, startPos, endPos ]);
    }

    /**
     */
    public getStepFromPos( script: string, pos: number ): WorkexPromise<number> {
        return this.client.post<number>(20 /* RuntimeApi.getStepFromPos */, [ script, pos ]);
    }

    /**
     * Set the script for the runtime, which starts executing
     * the script immediately
     */
    public onScriptChange( script: string ): WorkexPromise<void> {
        return this.client.postVoid(21 /* RuntimeApi.onScriptChange */, [ script ]);
    }

    /**
     * Resolve an item identifier search query to a list of items, ordered by score (best first).
     * Returns an empty list if no items are found.
     * 
     * cook effect is the game's representation, or 0 for no effect
     */
    public resolveItemIdent( query: string ): WorkexPromise<{ actor: string; cookEffect: number }[]> {
        return this.client.post<{ actor: string; cookEffect: number }[]>(22 /* RuntimeApi.resolveItemIdent */, [ query ]);
    }

    /**
     * Terminate the client and the underlying worker
     *
     * This method is generated by workex
     */
    public terminate() {
        this.client.terminate();
    }

    /**
     * Get the protocol identifier used by the underlying workex communication
     *
     * This method is generated by workex
     */
    public protocol(): "runtime" {
        return "runtime";
    }

    /**
     * Create a client-only handshake
     *
     * Generally, handshakes should be created using the `bindHost` function on each side.
     * However, if one side is a client-only side, this method can be used to bind a stub host
     * to establish the handshake.
     *
     * This method is generated by workex
     */
    public handshake() {
        return this.client.handshake();
    }
}